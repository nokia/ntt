// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at 2022-09-05 20:43:28.082573379 +0200 CEST m=+0.000870850

package syntax

// this is a minimal set of keywords required to parse TTCN-3.
// Note, that the standard specifies more keywords.
var keywords = map[string]Kind{
	"address":       AddressKeyword,
	"all":           AllKeyword,
	"alt":           AltKeyword,
	"altstep":       AltstepKeyword,
	"and4b":         And4bKeyword,
	"and":           AndKeyword,
	"any":           AnyKeyword,
	"case":          CaseKeyword,
	"catch":         CatchKeyword,
	"charstring":    CharstringKeyword,
	"class":         ClassKeyword,
	"component":     ComponentKeyword,
	"configuration": ConfigurationKeyword,
	"connect":       ConnectKeyword,
	"const":         ConstKeyword,
	"control":       ControlKeyword,
	"create":        CreateKeyword,
	"display":       DisplayKeyword,
	"do":            DoKeyword,
	"else":          ElseKeyword,
	"encode":        EncodeKeyword,
	"enumerated":    EnumeratedKeyword,
	"except":        ExceptKeyword,
	"exception":     ExceptionKeyword,
	"execute":       ExecuteKeyword,
	"extends":       ExtendsKeyword,
	"extension":     ExtensionKeyword,
	"external":      ExternalKeyword,
	"finally":       FinallyKeyword,
	"for":           ForKeyword,
	"friend":        FriendKeyword,
	"from":          FromKeyword,
	"function":      FunctionKeyword,
	"goto":          GotoKeyword,
	"group":         GroupKeyword,
	"if":            IfKeyword,
	"import":        ImportKeyword,
	"in":            InKeyword,
	"inout":         InoutKeyword,
	"interleave":    InterleaveKeyword,
	"label":         LabelKeyword,
	"language":      LanguageKeyword,
	"length":        LengthKeyword,
	"map":           MapKeyword,
	"message":       MessageKeyword,
	"mod":           ModKeyword,
	"modifies":      ModifiesKeyword,
	"module":        ModuleKeyword,
	"modulepar":     ModuleparKeyword,
	"mtc":           MtcKeyword,
	"noblock":       NoblockKeyword,
	"not4b":         Not4bKeyword,
	"not":           NotKeyword,
	"null":          NullKeyword,
	"of":            OfKeyword,
	"omit":          OmitKeyword,
	"on":            OnKeyword,
	"optional":      OptionalKeyword,
	"or4b":          Or4bKeyword,
	"or":            OrKeyword,
	"out":           OutKeyword,
	"override":      OverrideKeyword,
	"param":         ParamKeyword,
	"port":          PortKeyword,
	"present":       PresentKeyword,
	"private":       PrivateKeyword,
	"procedure":     ProcedureKeyword,
	"public":        PublicKeyword,
	"realtime":      RealtimeKeyword,
	"record":        RecordKeyword,
	"rem":           RemKeyword,
	"return":        ReturnKeyword,
	"runs":          RunsKeyword,
	"select":        SelectKeyword,
	"self":          SelfKeyword,
	"set":           SetKeyword,
	"signature":     SignatureKeyword,
	"stream":        StreamKeyword,
	"system":        SystemKeyword,
	"template":      TemplateKeyword,
	"testcase":      TestcaseKeyword,
	"this":          ThisKeyword,
	"timer":         TimerKeyword,
	"to":            ToKeyword,
	"type":          TypeKeyword,
	"union":         UnionKeyword,
	"universal":     UniversalKeyword,
	"unmap":         UnmapKeyword,
	"value":         ValueKeyword,
	"var":           VarKeyword,
	"variant":       VariantKeyword,
	"while":         WhileKeyword,
	"with":          WithKeyword,
	"xor4b":         Xor4bKeyword,
	"xor":           XorKeyword,
}

// Module = "module" Name [Language] "{" Decls "}" [With] [";"].
func (p *parser) parseModule() {
}

// Decls = { Decl [";"] }.
func (p *parser) parseDecls() {
}

// Decl = Altstep
//      | AltstepType
//      | Class
//      | Component
//      | Configuration
//      | Constructor
//      | Control
//      | Destructor
//      | Enum
//      | Friend
//      | Function
//      | FunctionType
//      | Group
//      | Import
//      | List
//      | Map
//      | Port
//      | Signature
//      | Struct
//      | SubType
//      | Template
//      | Testcase
//      | TestcaseType
//      | VarDecl
//      .
func (p *parser) parseDecl() {
}

// Group = [Visibility] "group" Name "{" Decls "}" [With].
func (p *parser) parseGroup() {
}

// Friend = [Visibility] "friend" "module" Refs [With].
func (p *parser) parseFriend() {
}

// Import = [Visibility] "import" "from" Ref ["->" Name] ("all" [ExceptSpec] | ImportSpec) [With].
func (p *parser) parseImport() {
}

// ExceptSpec = "except" "{" { ExceptStmt [";"] } "}".
func (p *parser) parseExceptSpec() {
}

// ExceptStmt = ImportKind (Refs|"all")
//            | "group"    (Refs|"all")
//            .
func (p *parser) parseExceptStmt() {
}

// ImportSpec = "{" { ImportStmt [";"] } "}".
func (p *parser) parseImportSpec() {
}

// ImportStmt = ImportKind (Refs|"all" ["except" Refs])
//            | "group"    {Ref [ExceptSpec]}
//            .
func (p *parser) parseImportStmt() {
}

// ImportKind
//     = "altstep"
//     | "const"
//     | "function"
//     | "import"
//     | "modulepar"
//     | "signature"
//     | "template"
//     | "testcase"
//     | "type"
//     .
func (p *parser) parseImportKind() {
}

// Signature = [Visibility] "signature" Name [FormalTypePars] FormalPars [Return] ["noblock"] [Exception] [With].
func (p *parser) parseSignature() {
}

// Component = [Visibility] "type" "component" Name [FormalTypePars][Extends] Block [With].
func (p *parser) parseComponent() {
}

// Port = [Visibility] "type" "port" Name PortKind {PortSpec} "{" {PortAttribute [";"]} "}" [With].
func (p *parser) parsePort() {
}

// PortKind = "message"
//          | "procedure"
// 	 | "stream"
// 	 .
func (p *parser) parsePortKind() {
}

// PortSpec = "realtime"
//          | "map" "to" Refs
// 	 | "connect" "to" Refs
// 	 .
func (p *parser) parsePortSpec() {
}

// PortAttribute = "map"   "param" FormalPars
//               | "unmap" "param" FormalPars
//               | "address" Ref [PortTranslation]
//               | ("in"|"out"|"inout") PortElement {"," PortElement} [","]
//               .
func (p *parser) parsePortAttribute() {
}

// PortElement = Ref [PortTranslation].
func (p *parser) parsePortElement() {
}

// PortTranslation =("from"|"to") Ref "with" Ref "(" ")".
func (p *parser) parsePortTranslation() {
}

// SubType = [Visibility] "type" Ref Name [FormalTypePars] {ArrayDef} [ValueConstraints] [With].
func (p *parser) parseSubType() {
}

// Struct = [Visibility] "type" StructKind Name [FormalTypePars]
//         "{"
//            StructMember {[","|";"] StructMember} [","|";"]
// 	"}" [With].
func (p *parser) parseStruct() {
}

// StructKind = "record" | "set" | "union".
func (p *parser) parseStructKind() {
}

// StructMember = ["@default"] NestedType Name {ArrayDef} [ValueConstraints].
func (p *parser) parseStructMember() {
}

// List = [Visibility] "type" ListKind ["length" "(" Expr ")"] "of" NestedType Name [With].
func (p *parser) parseList() {
}

// ListKind = "record" | "set".
func (p *parser) parseListKind() {
}

// Enum = [Visibility] "type" "enumerated" Name
//       "{"
//           EnumLabel {[","|";"] EnumLabel} [","|";"]
//       "}" [With].
func (p *parser) parseEnum() {
}

// EnumLabel = Name ["(" Expr ")"].
func (p *parser) parseEnumLabel() {
}

// Map = [Visibility] "type" "map" "from" Ref "to" Ref Name [With].
func (p *parser) parseMap() {
}

// Class = [Visibility] "type" ["external"] "class" {modif} Name [Extends] {ConfigSpec} "{" Decls "}" ["finally" Block] [With].
func (p *parser) parseClass() {
}

// Constructor = [Visibility] "create" FormalPars ["external" FormalPars] [":" Ref "(" [Exprs] ")" ] [Block] .
func (p *parser) parseConstructor() {
}

// Control = "control" Block.
func (p *parser) parseControl() {
}

// Destructor = "finally" Block.
func (p *parser) parseDestructor() {
}

// TestcaseType = [Visibility] "type" "testcase" Name FormalPars {ConfigSpec} [With].
func (p *parser) parseTestcaseType() {
}

// FunctionType = [Visibility] "type" "function" {modif} Name FormalPars {ConfigSpec} [Return] [With].
func (p *parser) parseFunctionType() {
}

// AltstepType = [Visibility] "type" "altstep" {modif} ["interleave"] Name FormalPars {ConfigSpec} [With].
func (p *parser) parseAltstepType() {
}

// VarDecl = [Visibility] ("const"|"var"|"modulepar") [NestedTemplate] {modif} Ref Declarator { "," Declarator} [With].
func (p *parser) parseVarDecl() {
}

// TimerDecl = "timer" Declarator { "," Declarator} [With].
func (p *parser) parseTimerDecl() {
}

// PortDecl = "port" Ref Declarator { "," Declarator} [With].
func (p *parser) parsePortDecl() {
}

// Template = [Visibility] "template" [ "(" TemplateRestriction ")"] {modif} Ref Name [FormalPars] ["modifies" Ref] ":=" Expr [With].
func (p *parser) parseTemplate() {
}

// Testcase = [Visibility] "testcase" Name FormalPars {ConfigSpec} Block.
func (p *parser) parseTestcase() {
}

// Function = [Visibility] ["external"] "function" {modif} Name FormalPars {ConfigSpec} [Return] [Exception] [Block] [With].
func (p *parser) parseFunction() {
}

// Configuration = [Visibility] "configuration" Name FormalPars {ConfigSpec} Block [With].
func (p *parser) parseConfiguration() {
}

// Altstep = [Visibility] "altstep" {modif} ["interleave"] Name FormalPars {ConfigSpec} Block [With].
func (p *parser) parseAltstep() {
}

// Stmt
//     = AltStmt
//     | Block
//     | DoStmt
//     | Expr
//     | ForStmt
//     | GotoStmt
//     | GuardStmt
//     | IfStmt
//     | LabelStmt
//     | PortDecl
//     | ReturnStmt
//     | SelectStmt
//     | Template
//     | TimerDecl
//     | VarDecl
//     | WhileStmt
//     .
func (p *parser) parseStmt() {
}

// IfStmt     = "if" "(" [(AssignStmt|VarDecl) ";"] Expr ")" Block {"else" "if" "(" Expr ")"} ["else" Block].
func (p *parser) parseIfStmt() {
}

// SelectStmt = "select" ["union"|"class"] "(" Expr ")" "{" { "case" ("else"|"(" Expr ")") Block } "}".
func (p *parser) parseSelectStmt() {
}

// ForStmt    = "for" "(" (AssignStmt|VarDecl) ("in" Ref|";" Expr";" AssignStmt) ")" Block.
func (p *parser) parseForStmt() {
}

// WhileStmt  = "while" "(" Expr ")" Block.
func (p *parser) parseWhileStmt() {
}

// DoStmt     = "do" Block "while" "(" Expr ")".
func (p *parser) parseDoStmt() {
}

// GotoStmt   = "goto" Ref.
func (p *parser) parseGotoStmt() {
}

// LabelStmt  = "label" Name.
func (p *parser) parseLabelStmt() {
}

// ReturnStmt = "return" [Expr].
func (p *parser) parseReturnStmt() {
}

// AltStmt    = ("alt"|"interleave") {modif} Block.
func (p *parser) parseAltStmt() {
}

// AssignStmt = Ref ":=" Expr.
func (p *parser) parseAssignStmt() {
}

// GuardStmt  = "[" [Expr] "]" Stmt.
func (p *parser) parseGuardStmt() {
}

// Block = BasicBlock ["catch" "(" Ref Name ")" BasicBlock] ["finally" BasicBlock].
func (p *parser) parseBlock() {
}

// BasicBlock = "{" { Stmt [";"] } "}".
func (p *parser) parseBasicBlock() {
}

// Exprs = Expr { "," Expr } "," .
func (p *parser) parseExprs() {
}

// PrimaryExpr = Ref { "." Ref | "[" Expr "]" | "(" [Exprs] ")" }.
func (p *parser) parsePrimaryExpr() {
}

// Literal = int
//         | float
// 	| string
// 	| bitstring
// 	| boolean
// 	| verdict
// 	| "-"
// 	| "?"
// 	| "*"
// 	| "omit"
// 	| "not_a_number"
// 	| "null"
// 	.
func (p *parser) parseLiteral() {
}

// Ref = id [TypePars]
//     | "address"
//     | "all" "component"
//     | "all" "port"
//     | "all" "timer"
//     | "any"
//     | "any" "component"
//     | "any" "port"
//     | "any" "timer"
//     | "map"
//     | "mtc"
//     | "self"
//     | "system"
//     | "this"
//     | "timer"
//     | "universal" "charstring"
//     | "unmap"
//     .
func (p *parser) parseRef() {
}

// TypePars = "<" TypePar { ","  TypePar } [","] ">" .
func (p *parser) parseTypePars() {
}

// TypePar = [ Name ":=" ] NestedType .
func (p *parser) parseTypePar() {
}

// With = "with" "{" {WithStmt} "}".
func (p *parser) parseWith() {
}

// WithStmt =  ("encode"|"variant"|"display"|"extension"|"optional") ["override"|"@local"] ["(" WithQualifier [","] ")"] string.
func (p *parser) parseWithStmt() {
}

// WithQualifier
//     = Ref
//     | "[" Expr "]"
//     | WithKind [ "except" "{" Refs "}" ]
//     .
func (p *parser) parseWithQualifier() {
}

// WithKind
//     = "altstep"
//     | "const"
//     | "function"
//     | "group"
//     | "modulepar"
//     | "signature"
//     | "template"
//     | "testcase"
//     | "type"
//     .
func (p *parser) parseWithKind() {
}

// Refs = Ref { "," Ref } [","].
func (p *parser) parseRefs() {
}

// Extends = "extends" Refs.
func (p *parser) parseExtends() {
}

// Language = "language" string { "," string } [","].
func (p *parser) parseLanguage() {
}

// Return = "return" [NestedTemplate] Ref {ArrayDef} .
func (p *parser) parseReturn() {
}

// ValueConstraints = "(" Expr { "," Expr } [","] ")".
func (p *parser) parseValueConstraints() {
}

// ConfigSpec
//     = "runs" "on" Ref
//     | "system" Ref
//     | "mtc" Ref
//     | "port" Ref
//     | "execute" "on" Ref
//     .
func (p *parser) parseConfigSpec() {
}

// Exception = "exception" "(" Refs ")".
func (p *parser) parseException() {
}

// Visibility = "private"|"public"|"friend".
func (p *parser) parseVisibility() {
}

// Name = id.
func (p *parser) parseName() {
}

// FormalTypePars = "<" FormalTypePar {"," FormalTypePar} [","] ">".
func (p *parser) parseFormalTypePars() {
}

// FormalTypePar = ["in"] ("type"|"signature"|Ref) Declarator.
func (p *parser) parseFormalTypePar() {
}

// FormalPars = "(" FormalPar {"," FormalPar} [","] ")".
func (p *parser) parseFormalPars() {
}

// FormalPar = ("in"|"out"|"inout") Ref Declarator.
func (p *parser) parseFormalPar() {
}

// Declarator = Name {ArrayDef} [":=" Expr].
func (p *parser) parseDeclarator() {
}

// ArrayDef = "[" Expr "]".
func (p *parser) parseArrayDef() {
}

// TemplateRestriction = "omit" | "value" | "present".
func (p *parser) parseTemplateRestriction() {
}

// NestedTemplate
//     = "template"
//     | "template" "(" TemplateRestriction ")"
//     | TemplateRestriction
//     .
func (p *parser) parseNestedTemplate() {
}

// NestedType
//     = Ref
//     | NestedStruct
//     | NestedList
//     | NestedEnum
//     .
func (p *parser) parseNestedType() {
}

// NestedStruct = ("record"|"set"|"union") "{" StructMember {[","|";"] StructMember} [","|";"] "}".
func (p *parser) parseNestedStruct() {
}

// NestedList = ("record"|"set") ["length" "(" Expr ")"] "of" NestedType.
func (p *parser) parseNestedList() {
}

// NestedEnum = "enumerated" "{" EnumLabel {[","|";"] EnumLabel} [","|";"] "}".
func (p *parser) parseNestedEnum() {
}
