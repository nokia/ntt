// Code generated by go generate; DO NOT EDIT.

package syntax

func (n *AltStmt) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.NoDefault != nil:
		return n.NoDefault

	case n.Body != nil:
		return n.Body.FirstTok()

	default:
		return nil
	}
}

func (n *AltStmt) LastTok() Token {
	switch {

	case n.Body != nil:
		return n.Body.LastTok()

	case n.NoDefault != nil:
		return n.NoDefault

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *AltStmt) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.NoDefault != nil {
		ret = append(ret, n.NoDefault)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	return ret
}

func (n *AltStmt) Inspect(f func(Node) bool) {

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *AltStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *AltStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *BehaviourSpec) FirstTok() Token {
	switch {

	case n.Kind != nil:
		return n.Kind

	case n.Params != nil:
		return n.Params.FirstTok()

	case n.RunsOn != nil:
		return n.RunsOn.FirstTok()

	case n.System != nil:
		return n.System.FirstTok()

	case n.Return != nil:
		return n.Return.FirstTok()

	default:
		return nil
	}
}

func (n *BehaviourSpec) LastTok() Token {
	switch {

	case n.Return != nil:
		return n.Return.LastTok()

	case n.System != nil:
		return n.System.LastTok()

	case n.RunsOn != nil:
		return n.RunsOn.LastTok()

	case n.Params != nil:
		return n.Params.LastTok()

	case n.Kind != nil:
		return n.Kind

	default:
		return nil
	}
}

func (n *BehaviourSpec) Children() []Node {
	ret := make([]Node, 0, 5)

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.Params != nil {
		ret = append(ret, n.Params)
	}

	if n.RunsOn != nil {
		ret = append(ret, n.RunsOn)
	}

	if n.System != nil {
		ret = append(ret, n.System)
	}

	if n.Return != nil {
		ret = append(ret, n.Return)
	}

	return ret
}

func (n *BehaviourSpec) Inspect(f func(Node) bool) {

	if c := n.Params; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.RunsOn; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.System; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Return; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *BehaviourSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *BehaviourSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *BehaviourTypeDecl) FirstTok() Token {
	switch {

	case n.TypeTok != nil:
		return n.TypeTok

	case n.Kind != nil:
		return n.Kind

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.TypePars != nil:
		return n.TypePars.FirstTok()

	case n.Params != nil:
		return n.Params.FirstTok()

	case n.RunsOn != nil:
		return n.RunsOn.FirstTok()

	case n.System != nil:
		return n.System.FirstTok()

	case n.Return != nil:
		return n.Return.FirstTok()

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *BehaviourTypeDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.Return != nil:
		return n.Return.LastTok()

	case n.System != nil:
		return n.System.LastTok()

	case n.RunsOn != nil:
		return n.RunsOn.LastTok()

	case n.Params != nil:
		return n.Params.LastTok()

	case n.TypePars != nil:
		return n.TypePars.LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Kind != nil:
		return n.Kind

	case n.TypeTok != nil:
		return n.TypeTok

	default:
		return nil
	}
}

func (n *BehaviourTypeDecl) Children() []Node {
	ret := make([]Node, 0, 9)

	if n.TypeTok != nil {
		ret = append(ret, n.TypeTok)
	}

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.TypePars != nil {
		ret = append(ret, n.TypePars)
	}

	if n.Params != nil {
		ret = append(ret, n.Params)
	}

	if n.RunsOn != nil {
		ret = append(ret, n.RunsOn)
	}

	if n.System != nil {
		ret = append(ret, n.System)
	}

	if n.Return != nil {
		ret = append(ret, n.Return)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *BehaviourTypeDecl) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.TypePars; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Params; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.RunsOn; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.System; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Return; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *BehaviourTypeDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *BehaviourTypeDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *BinaryExpr) FirstTok() Token {
	switch {

	case n.X != nil:
		return n.X.FirstTok()

	case n.Op != nil:
		return n.Op

	case n.Y != nil:
		return n.Y.FirstTok()

	default:
		return nil
	}
}

func (n *BinaryExpr) LastTok() Token {
	switch {

	case n.Y != nil:
		return n.Y.LastTok()

	case n.Op != nil:
		return n.Op

	case n.X != nil:
		return n.X.LastTok()

	default:
		return nil
	}
}

func (n *BinaryExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.Op != nil {
		ret = append(ret, n.Op)
	}

	if n.Y != nil {
		ret = append(ret, n.Y)
	}

	return ret
}

func (n *BinaryExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Y; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *BinaryExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *BinaryExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *BlockStmt) FirstTok() Token {
	switch {

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Stmts) > 0:
		return n.Stmts[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	default:
		return nil
	}
}

func (n *BlockStmt) LastTok() Token {
	switch {

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Stmts) > 0:
		return n.Stmts[len(n.Stmts)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	default:
		return nil
	}
}

func (n *BlockStmt) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Stmts {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	return ret
}

func (n *BlockStmt) Inspect(f func(Node) bool) {

	for _, c := range n.Stmts {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *BlockStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *BlockStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *BranchStmt) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Label != nil:
		return n.Label.FirstTok()

	default:
		return nil
	}
}

func (n *BranchStmt) LastTok() Token {
	switch {

	case n.Label != nil:
		return n.Label.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *BranchStmt) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Label != nil {
		ret = append(ret, n.Label)
	}

	return ret
}

func (n *BranchStmt) Inspect(f func(Node) bool) {

	if c := n.Label; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *BranchStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *BranchStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *CallExpr) FirstTok() Token {
	switch {

	case n.Fun != nil:
		return n.Fun.FirstTok()

	case n.Args != nil:
		return n.Args.FirstTok()

	default:
		return nil
	}
}

func (n *CallExpr) LastTok() Token {
	switch {

	case n.Args != nil:
		return n.Args.LastTok()

	case n.Fun != nil:
		return n.Fun.LastTok()

	default:
		return nil
	}
}

func (n *CallExpr) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Fun != nil {
		ret = append(ret, n.Fun)
	}

	if n.Args != nil {
		ret = append(ret, n.Args)
	}

	return ret
}

func (n *CallExpr) Inspect(f func(Node) bool) {

	if c := n.Fun; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Args; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *CallExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *CallExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *CallStmt) FirstTok() Token {
	switch {

	case n.Stmt != nil:
		return n.Stmt.FirstTok()

	case n.Body != nil:
		return n.Body.FirstTok()

	default:
		return nil
	}
}

func (n *CallStmt) LastTok() Token {
	switch {

	case n.Body != nil:
		return n.Body.LastTok()

	case n.Stmt != nil:
		return n.Stmt.LastTok()

	default:
		return nil
	}
}

func (n *CallStmt) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Stmt != nil {
		ret = append(ret, n.Stmt)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	return ret
}

func (n *CallStmt) Inspect(f func(Node) bool) {

	if c := n.Stmt; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *CallStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *CallStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *CaseClause) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Case != nil:
		return n.Case.FirstTok()

	case n.Body != nil:
		return n.Body.FirstTok()

	default:
		return nil
	}
}

func (n *CaseClause) LastTok() Token {
	switch {

	case n.Body != nil:
		return n.Body.LastTok()

	case n.Case != nil:
		return n.Case.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *CaseClause) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Case != nil {
		ret = append(ret, n.Case)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	return ret
}

func (n *CaseClause) Inspect(f func(Node) bool) {

	if c := n.Case; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *CaseClause) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *CaseClause) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ClassTypeDecl) FirstTok() Token {
	switch {

	case n.TypeTok != nil:
		return n.TypeTok

	case n.Kind != nil:
		return n.Kind

	case n.Modif != nil:
		return n.Modif

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.ExtendsTok != nil:
		return n.ExtendsTok

	case len(n.Extends) > 0:
		return n.Extends[0].FirstTok()

	case n.RunsOn != nil:
		return n.RunsOn.FirstTok()

	case n.Mtc != nil:
		return n.Mtc.FirstTok()

	case n.System != nil:
		return n.System.FirstTok()

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Defs) > 0:
		return n.Defs[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *ClassTypeDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Defs) > 0:
		return n.Defs[len(n.Defs)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.System != nil:
		return n.System.LastTok()

	case n.Mtc != nil:
		return n.Mtc.LastTok()

	case n.RunsOn != nil:
		return n.RunsOn.LastTok()

	case len(n.Extends) > 0:
		return n.Extends[len(n.Extends)-1].LastTok()

	case n.ExtendsTok != nil:
		return n.ExtendsTok

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Modif != nil:
		return n.Modif

	case n.Kind != nil:
		return n.Kind

	case n.TypeTok != nil:
		return n.TypeTok

	default:
		return nil
	}
}

func (n *ClassTypeDecl) Children() []Node {
	ret := make([]Node, 0, 13)

	if n.TypeTok != nil {
		ret = append(ret, n.TypeTok)
	}

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.Modif != nil {
		ret = append(ret, n.Modif)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.ExtendsTok != nil {
		ret = append(ret, n.ExtendsTok)
	}

	for _, c := range n.Extends {
		ret = append(ret, c)
	}

	if n.RunsOn != nil {
		ret = append(ret, n.RunsOn)
	}

	if n.Mtc != nil {
		ret = append(ret, n.Mtc)
	}

	if n.System != nil {
		ret = append(ret, n.System)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Defs {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *ClassTypeDecl) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Extends {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.RunsOn; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Mtc; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.System; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Defs {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ClassTypeDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ClassTypeDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *CommClause) FirstTok() Token {
	switch {

	case n.LBrack != nil:
		return n.LBrack

	case n.X != nil:
		return n.X.FirstTok()

	case n.Else != nil:
		return n.Else

	case n.RBrack != nil:
		return n.RBrack

	case n.Comm != nil:
		return n.Comm.FirstTok()

	case n.Body != nil:
		return n.Body.FirstTok()

	default:
		return nil
	}
}

func (n *CommClause) LastTok() Token {
	switch {

	case n.Body != nil:
		return n.Body.LastTok()

	case n.Comm != nil:
		return n.Comm.LastTok()

	case n.RBrack != nil:
		return n.RBrack

	case n.Else != nil:
		return n.Else

	case n.X != nil:
		return n.X.LastTok()

	case n.LBrack != nil:
		return n.LBrack

	default:
		return nil
	}
}

func (n *CommClause) Children() []Node {
	ret := make([]Node, 0, 6)

	if n.LBrack != nil {
		ret = append(ret, n.LBrack)
	}

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.Else != nil {
		ret = append(ret, n.Else)
	}

	if n.RBrack != nil {
		ret = append(ret, n.RBrack)
	}

	if n.Comm != nil {
		ret = append(ret, n.Comm)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	return ret
}

func (n *CommClause) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Comm; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *CommClause) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *CommClause) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ComponentTypeDecl) FirstTok() Token {
	switch {

	case n.TypeTok != nil:
		return n.TypeTok

	case n.CompTok != nil:
		return n.CompTok

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.TypePars != nil:
		return n.TypePars.FirstTok()

	case n.ExtendsTok != nil:
		return n.ExtendsTok

	case len(n.Extends) > 0:
		return n.Extends[0].FirstTok()

	case n.Body != nil:
		return n.Body.FirstTok()

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *ComponentTypeDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.Body != nil:
		return n.Body.LastTok()

	case len(n.Extends) > 0:
		return n.Extends[len(n.Extends)-1].LastTok()

	case n.ExtendsTok != nil:
		return n.ExtendsTok

	case n.TypePars != nil:
		return n.TypePars.LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.CompTok != nil:
		return n.CompTok

	case n.TypeTok != nil:
		return n.TypeTok

	default:
		return nil
	}
}

func (n *ComponentTypeDecl) Children() []Node {
	ret := make([]Node, 0, 8)

	if n.TypeTok != nil {
		ret = append(ret, n.TypeTok)
	}

	if n.CompTok != nil {
		ret = append(ret, n.CompTok)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.TypePars != nil {
		ret = append(ret, n.TypePars)
	}

	if n.ExtendsTok != nil {
		ret = append(ret, n.ExtendsTok)
	}

	for _, c := range n.Extends {
		ret = append(ret, c)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *ComponentTypeDecl) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.TypePars; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Extends {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ComponentTypeDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ComponentTypeDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *CompositeLiteral) FirstTok() Token {
	switch {

	case n.LBrace != nil:
		return n.LBrace

	case len(n.List) > 0:
		return n.List[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	default:
		return nil
	}
}

func (n *CompositeLiteral) LastTok() Token {
	switch {

	case n.RBrace != nil:
		return n.RBrace

	case len(n.List) > 0:
		return n.List[len(n.List)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	default:
		return nil
	}
}

func (n *CompositeLiteral) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.List {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	return ret
}

func (n *CompositeLiteral) Inspect(f func(Node) bool) {

	for _, c := range n.List {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *CompositeLiteral) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *CompositeLiteral) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ConstructorDecl) FirstTok() Token {
	switch {

	case n.CreateTok != nil:
		return n.CreateTok

	case n.Params != nil:
		return n.Params.FirstTok()

	case n.Body != nil:
		return n.Body.FirstTok()

	default:
		return nil
	}
}

func (n *ConstructorDecl) LastTok() Token {
	switch {

	case n.Body != nil:
		return n.Body.LastTok()

	case n.Params != nil:
		return n.Params.LastTok()

	case n.CreateTok != nil:
		return n.CreateTok

	default:
		return nil
	}
}

func (n *ConstructorDecl) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.CreateTok != nil {
		ret = append(ret, n.CreateTok)
	}

	if n.Params != nil {
		ret = append(ret, n.Params)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	return ret
}

func (n *ConstructorDecl) Inspect(f func(Node) bool) {

	if c := n.Params; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ConstructorDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ConstructorDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ControlPart) FirstTok() Token {
	switch {

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.Body != nil:
		return n.Body.FirstTok()

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *ControlPart) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.Body != nil:
		return n.Body.LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	default:
		return nil
	}
}

func (n *ControlPart) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *ControlPart) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ControlPart) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ControlPart) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *DeclStmt) FirstTok() Token {
	switch {

	case n.Decl != nil:
		return n.Decl.FirstTok()

	default:
		return nil
	}
}

func (n *DeclStmt) LastTok() Token {
	switch {

	case n.Decl != nil:
		return n.Decl.LastTok()

	default:
		return nil
	}
}

func (n *DeclStmt) Children() []Node {
	ret := make([]Node, 0, 1)

	if n.Decl != nil {
		ret = append(ret, n.Decl)
	}

	return ret
}

func (n *DeclStmt) Inspect(f func(Node) bool) {

	if c := n.Decl; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *DeclStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *DeclStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *Declarator) FirstTok() Token {
	switch {

	case n.Name != nil:
		return n.Name.FirstTok()

	case len(n.ArrayDef) > 0:
		return n.ArrayDef[0].FirstTok()

	case n.AssignTok != nil:
		return n.AssignTok

	case n.Value != nil:
		return n.Value.FirstTok()

	default:
		return nil
	}
}

func (n *Declarator) LastTok() Token {
	switch {

	case n.Value != nil:
		return n.Value.LastTok()

	case n.AssignTok != nil:
		return n.AssignTok

	case len(n.ArrayDef) > 0:
		return n.ArrayDef[len(n.ArrayDef)-1].LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	default:
		return nil
	}
}

func (n *Declarator) Children() []Node {
	ret := make([]Node, 0, 4)

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	for _, c := range n.ArrayDef {
		ret = append(ret, c)
	}

	if n.AssignTok != nil {
		ret = append(ret, n.AssignTok)
	}

	if n.Value != nil {
		ret = append(ret, n.Value)
	}

	return ret
}

func (n *Declarator) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.ArrayDef {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Value; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *Declarator) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *Declarator) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *DecmatchExpr) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Params != nil:
		return n.Params.FirstTok()

	case n.X != nil:
		return n.X.FirstTok()

	default:
		return nil
	}
}

func (n *DecmatchExpr) LastTok() Token {
	switch {

	case n.X != nil:
		return n.X.LastTok()

	case n.Params != nil:
		return n.Params.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *DecmatchExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Params != nil {
		ret = append(ret, n.Params)
	}

	if n.X != nil {
		ret = append(ret, n.X)
	}

	return ret
}

func (n *DecmatchExpr) Inspect(f func(Node) bool) {

	if c := n.Params; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *DecmatchExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *DecmatchExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *DecodedExpr) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Params != nil:
		return n.Params.FirstTok()

	case n.X != nil:
		return n.X.FirstTok()

	default:
		return nil
	}
}

func (n *DecodedExpr) LastTok() Token {
	switch {

	case n.X != nil:
		return n.X.LastTok()

	case n.Params != nil:
		return n.Params.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *DecodedExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Params != nil {
		ret = append(ret, n.Params)
	}

	if n.X != nil {
		ret = append(ret, n.X)
	}

	return ret
}

func (n *DecodedExpr) Inspect(f func(Node) bool) {

	if c := n.Params; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *DecodedExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *DecodedExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *DefKindExpr) FirstTok() Token {
	switch {

	case n.Kind != nil:
		return n.Kind

	case len(n.List) > 0:
		return n.List[0].FirstTok()

	default:
		return nil
	}
}

func (n *DefKindExpr) LastTok() Token {
	switch {

	case len(n.List) > 0:
		return n.List[len(n.List)-1].LastTok()

	case n.Kind != nil:
		return n.Kind

	default:
		return nil
	}
}

func (n *DefKindExpr) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	for _, c := range n.List {
		ret = append(ret, c)
	}

	return ret
}

func (n *DefKindExpr) Inspect(f func(Node) bool) {

	for _, c := range n.List {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *DefKindExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *DefKindExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *DoWhileStmt) FirstTok() Token {
	switch {

	case n.DoTok != nil:
		return n.DoTok

	case n.Body != nil:
		return n.Body.FirstTok()

	case n.WhileTok != nil:
		return n.WhileTok

	case n.LParen != nil:
		return n.LParen

	case n.Cond != nil:
		return n.Cond.FirstTok()

	case n.RParen != nil:
		return n.RParen

	default:
		return nil
	}
}

func (n *DoWhileStmt) LastTok() Token {
	switch {

	case n.RParen != nil:
		return n.RParen

	case n.Cond != nil:
		return n.Cond.LastTok()

	case n.LParen != nil:
		return n.LParen

	case n.WhileTok != nil:
		return n.WhileTok

	case n.Body != nil:
		return n.Body.LastTok()

	case n.DoTok != nil:
		return n.DoTok

	default:
		return nil
	}
}

func (n *DoWhileStmt) Children() []Node {
	ret := make([]Node, 0, 6)

	if n.DoTok != nil {
		ret = append(ret, n.DoTok)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	if n.WhileTok != nil {
		ret = append(ret, n.WhileTok)
	}

	if n.LParen != nil {
		ret = append(ret, n.LParen)
	}

	if n.Cond != nil {
		ret = append(ret, n.Cond)
	}

	if n.RParen != nil {
		ret = append(ret, n.RParen)
	}

	return ret
}

func (n *DoWhileStmt) Inspect(f func(Node) bool) {

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Cond; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *DoWhileStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *DoWhileStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *DynamicExpr) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Body != nil:
		return n.Body.FirstTok()

	default:
		return nil
	}
}

func (n *DynamicExpr) LastTok() Token {
	switch {

	case n.Body != nil:
		return n.Body.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *DynamicExpr) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	return ret
}

func (n *DynamicExpr) Inspect(f func(Node) bool) {

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *DynamicExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *DynamicExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *EnumSpec) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Enums) > 0:
		return n.Enums[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	default:
		return nil
	}
}

func (n *EnumSpec) LastTok() Token {
	switch {

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Enums) > 0:
		return n.Enums[len(n.Enums)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *EnumSpec) Children() []Node {
	ret := make([]Node, 0, 4)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Enums {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	return ret
}

func (n *EnumSpec) Inspect(f func(Node) bool) {

	for _, c := range n.Enums {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *EnumSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *EnumSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *EnumTypeDecl) FirstTok() Token {
	switch {

	case n.TypeTok != nil:
		return n.TypeTok

	case n.EnumTok != nil:
		return n.EnumTok

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.TypePars != nil:
		return n.TypePars.FirstTok()

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Enums) > 0:
		return n.Enums[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *EnumTypeDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Enums) > 0:
		return n.Enums[len(n.Enums)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.TypePars != nil:
		return n.TypePars.LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.EnumTok != nil:
		return n.EnumTok

	case n.TypeTok != nil:
		return n.TypeTok

	default:
		return nil
	}
}

func (n *EnumTypeDecl) Children() []Node {
	ret := make([]Node, 0, 8)

	if n.TypeTok != nil {
		ret = append(ret, n.TypeTok)
	}

	if n.EnumTok != nil {
		ret = append(ret, n.EnumTok)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.TypePars != nil {
		ret = append(ret, n.TypePars)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Enums {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *EnumTypeDecl) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.TypePars; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Enums {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *EnumTypeDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *EnumTypeDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ErrorNode) FirstTok() Token {
	switch {

	case n.From != nil:
		return n.From

	case n.To != nil:
		return n.To

	default:
		return nil
	}
}

func (n *ErrorNode) LastTok() Token {
	switch {

	case n.To != nil:
		return n.To

	case n.From != nil:
		return n.From

	default:
		return nil
	}
}

func (n *ErrorNode) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.From != nil {
		ret = append(ret, n.From)
	}

	if n.To != nil {
		ret = append(ret, n.To)
	}

	return ret
}

func (n *ErrorNode) Inspect(f func(Node) bool) {

}

func (n *ErrorNode) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ErrorNode) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ExceptExpr) FirstTok() Token {
	switch {

	case n.X != nil:
		return n.X.FirstTok()

	case n.ExceptTok != nil:
		return n.ExceptTok

	case n.LBrace != nil:
		return n.LBrace

	case len(n.List) > 0:
		return n.List[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	default:
		return nil
	}
}

func (n *ExceptExpr) LastTok() Token {
	switch {

	case n.RBrace != nil:
		return n.RBrace

	case len(n.List) > 0:
		return n.List[len(n.List)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.ExceptTok != nil:
		return n.ExceptTok

	case n.X != nil:
		return n.X.LastTok()

	default:
		return nil
	}
}

func (n *ExceptExpr) Children() []Node {
	ret := make([]Node, 0, 5)

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.ExceptTok != nil {
		ret = append(ret, n.ExceptTok)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.List {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	return ret
}

func (n *ExceptExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.List {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ExceptExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ExceptExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ExprStmt) FirstTok() Token {
	switch {

	case n.Expr != nil:
		return n.Expr.FirstTok()

	default:
		return nil
	}
}

func (n *ExprStmt) LastTok() Token {
	switch {

	case n.Expr != nil:
		return n.Expr.LastTok()

	default:
		return nil
	}
}

func (n *ExprStmt) Children() []Node {
	ret := make([]Node, 0, 1)

	if n.Expr != nil {
		ret = append(ret, n.Expr)
	}

	return ret
}

func (n *ExprStmt) Inspect(f func(Node) bool) {

	if c := n.Expr; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ExprStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ExprStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *Field) FirstTok() Token {
	switch {

	case n.DefaultTok != nil:
		return n.DefaultTok

	case n.Type != nil:
		return n.Type.FirstTok()

	case n.Name != nil:
		return n.Name.FirstTok()

	case len(n.ArrayDef) > 0:
		return n.ArrayDef[0].FirstTok()

	case n.TypePars != nil:
		return n.TypePars.FirstTok()

	case n.ValueConstraint != nil:
		return n.ValueConstraint.FirstTok()

	case n.LengthConstraint != nil:
		return n.LengthConstraint.FirstTok()

	case n.Optional != nil:
		return n.Optional

	default:
		return nil
	}
}

func (n *Field) LastTok() Token {
	switch {

	case n.Optional != nil:
		return n.Optional

	case n.LengthConstraint != nil:
		return n.LengthConstraint.LastTok()

	case n.ValueConstraint != nil:
		return n.ValueConstraint.LastTok()

	case n.TypePars != nil:
		return n.TypePars.LastTok()

	case len(n.ArrayDef) > 0:
		return n.ArrayDef[len(n.ArrayDef)-1].LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Type != nil:
		return n.Type.LastTok()

	case n.DefaultTok != nil:
		return n.DefaultTok

	default:
		return nil
	}
}

func (n *Field) Children() []Node {
	ret := make([]Node, 0, 8)

	if n.DefaultTok != nil {
		ret = append(ret, n.DefaultTok)
	}

	if n.Type != nil {
		ret = append(ret, n.Type)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	for _, c := range n.ArrayDef {
		ret = append(ret, c)
	}

	if n.TypePars != nil {
		ret = append(ret, n.TypePars)
	}

	if n.ValueConstraint != nil {
		ret = append(ret, n.ValueConstraint)
	}

	if n.LengthConstraint != nil {
		ret = append(ret, n.LengthConstraint)
	}

	if n.Optional != nil {
		ret = append(ret, n.Optional)
	}

	return ret
}

func (n *Field) Inspect(f func(Node) bool) {

	if c := n.Type; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.ArrayDef {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.TypePars; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.ValueConstraint; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.LengthConstraint; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *Field) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *Field) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ForRangeStmt) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.LParen != nil:
		return n.LParen

	case n.VarTok != nil:
		return n.VarTok

	case n.Type != nil:
		return n.Type.FirstTok()

	case n.Var != nil:
		return n.Var.FirstTok()

	case n.InTok != nil:
		return n.InTok

	case n.Range != nil:
		return n.Range.FirstTok()

	case n.RParen != nil:
		return n.RParen

	case n.Body != nil:
		return n.Body.FirstTok()

	default:
		return nil
	}
}

func (n *ForRangeStmt) LastTok() Token {
	switch {

	case n.Body != nil:
		return n.Body.LastTok()

	case n.RParen != nil:
		return n.RParen

	case n.Range != nil:
		return n.Range.LastTok()

	case n.InTok != nil:
		return n.InTok

	case n.Var != nil:
		return n.Var.LastTok()

	case n.Type != nil:
		return n.Type.LastTok()

	case n.VarTok != nil:
		return n.VarTok

	case n.LParen != nil:
		return n.LParen

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *ForRangeStmt) Children() []Node {
	ret := make([]Node, 0, 9)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.LParen != nil {
		ret = append(ret, n.LParen)
	}

	if n.VarTok != nil {
		ret = append(ret, n.VarTok)
	}

	if n.Type != nil {
		ret = append(ret, n.Type)
	}

	if n.Var != nil {
		ret = append(ret, n.Var)
	}

	if n.InTok != nil {
		ret = append(ret, n.InTok)
	}

	if n.Range != nil {
		ret = append(ret, n.Range)
	}

	if n.RParen != nil {
		ret = append(ret, n.RParen)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	return ret
}

func (n *ForRangeStmt) Inspect(f func(Node) bool) {

	if c := n.Type; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Var; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Range; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ForRangeStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ForRangeStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ForStmt) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.LParen != nil:
		return n.LParen

	case n.Init != nil:
		return n.Init.FirstTok()

	case n.InitSemi != nil:
		return n.InitSemi

	case n.Cond != nil:
		return n.Cond.FirstTok()

	case n.CondSemi != nil:
		return n.CondSemi

	case n.Post != nil:
		return n.Post.FirstTok()

	case n.RParen != nil:
		return n.RParen

	case n.Body != nil:
		return n.Body.FirstTok()

	default:
		return nil
	}
}

func (n *ForStmt) LastTok() Token {
	switch {

	case n.Body != nil:
		return n.Body.LastTok()

	case n.RParen != nil:
		return n.RParen

	case n.Post != nil:
		return n.Post.LastTok()

	case n.CondSemi != nil:
		return n.CondSemi

	case n.Cond != nil:
		return n.Cond.LastTok()

	case n.InitSemi != nil:
		return n.InitSemi

	case n.Init != nil:
		return n.Init.LastTok()

	case n.LParen != nil:
		return n.LParen

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *ForStmt) Children() []Node {
	ret := make([]Node, 0, 9)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.LParen != nil {
		ret = append(ret, n.LParen)
	}

	if n.Init != nil {
		ret = append(ret, n.Init)
	}

	if n.InitSemi != nil {
		ret = append(ret, n.InitSemi)
	}

	if n.Cond != nil {
		ret = append(ret, n.Cond)
	}

	if n.CondSemi != nil {
		ret = append(ret, n.CondSemi)
	}

	if n.Post != nil {
		ret = append(ret, n.Post)
	}

	if n.RParen != nil {
		ret = append(ret, n.RParen)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	return ret
}

func (n *ForStmt) Inspect(f func(Node) bool) {

	if c := n.Init; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Cond; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Post; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ForStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ForStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *FormalPar) FirstTok() Token {
	switch {

	case n.Direction != nil:
		return n.Direction

	case n.TemplateRestriction != nil:
		return n.TemplateRestriction.FirstTok()

	case n.Modif != nil:
		return n.Modif

	case n.Type != nil:
		return n.Type.FirstTok()

	case n.Name != nil:
		return n.Name.FirstTok()

	case len(n.ArrayDef) > 0:
		return n.ArrayDef[0].FirstTok()

	case n.AssignTok != nil:
		return n.AssignTok

	case n.Value != nil:
		return n.Value.FirstTok()

	default:
		return nil
	}
}

func (n *FormalPar) LastTok() Token {
	switch {

	case n.Value != nil:
		return n.Value.LastTok()

	case n.AssignTok != nil:
		return n.AssignTok

	case len(n.ArrayDef) > 0:
		return n.ArrayDef[len(n.ArrayDef)-1].LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Type != nil:
		return n.Type.LastTok()

	case n.Modif != nil:
		return n.Modif

	case n.TemplateRestriction != nil:
		return n.TemplateRestriction.LastTok()

	case n.Direction != nil:
		return n.Direction

	default:
		return nil
	}
}

func (n *FormalPar) Children() []Node {
	ret := make([]Node, 0, 8)

	if n.Direction != nil {
		ret = append(ret, n.Direction)
	}

	if n.TemplateRestriction != nil {
		ret = append(ret, n.TemplateRestriction)
	}

	if n.Modif != nil {
		ret = append(ret, n.Modif)
	}

	if n.Type != nil {
		ret = append(ret, n.Type)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	for _, c := range n.ArrayDef {
		ret = append(ret, c)
	}

	if n.AssignTok != nil {
		ret = append(ret, n.AssignTok)
	}

	if n.Value != nil {
		ret = append(ret, n.Value)
	}

	return ret
}

func (n *FormalPar) Inspect(f func(Node) bool) {

	if c := n.TemplateRestriction; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Type; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.ArrayDef {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Value; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *FormalPar) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *FormalPar) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *FormalPars) FirstTok() Token {
	switch {

	case n.LParen != nil:
		return n.LParen

	case len(n.List) > 0:
		return n.List[0].FirstTok()

	case n.RParen != nil:
		return n.RParen

	default:
		return nil
	}
}

func (n *FormalPars) LastTok() Token {
	switch {

	case n.RParen != nil:
		return n.RParen

	case len(n.List) > 0:
		return n.List[len(n.List)-1].LastTok()

	case n.LParen != nil:
		return n.LParen

	default:
		return nil
	}
}

func (n *FormalPars) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.LParen != nil {
		ret = append(ret, n.LParen)
	}

	for _, c := range n.List {
		ret = append(ret, c)
	}

	if n.RParen != nil {
		ret = append(ret, n.RParen)
	}

	return ret
}

func (n *FormalPars) Inspect(f func(Node) bool) {

	for _, c := range n.List {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *FormalPars) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *FormalPars) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *FriendDecl) FirstTok() Token {
	switch {

	case n.FriendTok != nil:
		return n.FriendTok

	case n.ModuleTok != nil:
		return n.ModuleTok

	case n.Module != nil:
		return n.Module.FirstTok()

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *FriendDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.Module != nil:
		return n.Module.LastTok()

	case n.ModuleTok != nil:
		return n.ModuleTok

	case n.FriendTok != nil:
		return n.FriendTok

	default:
		return nil
	}
}

func (n *FriendDecl) Children() []Node {
	ret := make([]Node, 0, 4)

	if n.FriendTok != nil {
		ret = append(ret, n.FriendTok)
	}

	if n.ModuleTok != nil {
		ret = append(ret, n.ModuleTok)
	}

	if n.Module != nil {
		ret = append(ret, n.Module)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *FriendDecl) Inspect(f func(Node) bool) {

	if c := n.Module; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *FriendDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *FriendDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *FromExpr) FirstTok() Token {
	switch {

	case n.Kind != nil:
		return n.Kind

	case n.FromTok != nil:
		return n.FromTok

	case n.X != nil:
		return n.X.FirstTok()

	default:
		return nil
	}
}

func (n *FromExpr) LastTok() Token {
	switch {

	case n.X != nil:
		return n.X.LastTok()

	case n.FromTok != nil:
		return n.FromTok

	case n.Kind != nil:
		return n.Kind

	default:
		return nil
	}
}

func (n *FromExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.FromTok != nil {
		ret = append(ret, n.FromTok)
	}

	if n.X != nil {
		ret = append(ret, n.X)
	}

	return ret
}

func (n *FromExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *FromExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *FromExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *FuncDecl) FirstTok() Token {
	switch {

	case n.External != nil:
		return n.External

	case n.Kind != nil:
		return n.Kind

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.Modif != nil:
		return n.Modif

	case n.TypePars != nil:
		return n.TypePars.FirstTok()

	case n.Params != nil:
		return n.Params.FirstTok()

	case n.RunsOn != nil:
		return n.RunsOn.FirstTok()

	case n.Mtc != nil:
		return n.Mtc.FirstTok()

	case n.System != nil:
		return n.System.FirstTok()

	case n.Return != nil:
		return n.Return.FirstTok()

	case n.Body != nil:
		return n.Body.FirstTok()

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *FuncDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.Body != nil:
		return n.Body.LastTok()

	case n.Return != nil:
		return n.Return.LastTok()

	case n.System != nil:
		return n.System.LastTok()

	case n.Mtc != nil:
		return n.Mtc.LastTok()

	case n.RunsOn != nil:
		return n.RunsOn.LastTok()

	case n.Params != nil:
		return n.Params.LastTok()

	case n.TypePars != nil:
		return n.TypePars.LastTok()

	case n.Modif != nil:
		return n.Modif

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Kind != nil:
		return n.Kind

	case n.External != nil:
		return n.External

	default:
		return nil
	}
}

func (n *FuncDecl) Children() []Node {
	ret := make([]Node, 0, 12)

	if n.External != nil {
		ret = append(ret, n.External)
	}

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.Modif != nil {
		ret = append(ret, n.Modif)
	}

	if n.TypePars != nil {
		ret = append(ret, n.TypePars)
	}

	if n.Params != nil {
		ret = append(ret, n.Params)
	}

	if n.RunsOn != nil {
		ret = append(ret, n.RunsOn)
	}

	if n.Mtc != nil {
		ret = append(ret, n.Mtc)
	}

	if n.System != nil {
		ret = append(ret, n.System)
	}

	if n.Return != nil {
		ret = append(ret, n.Return)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *FuncDecl) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.TypePars; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Params; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.RunsOn; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Mtc; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.System; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Return; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *FuncDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *FuncDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *GroupDecl) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Defs) > 0:
		return n.Defs[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *GroupDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Defs) > 0:
		return n.Defs[len(n.Defs)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *GroupDecl) Children() []Node {
	ret := make([]Node, 0, 6)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Defs {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *GroupDecl) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Defs {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *GroupDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *GroupDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *Ident) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Tok2 != nil:
		return n.Tok2

	default:
		return nil
	}
}

func (n *Ident) LastTok() Token {
	switch {

	case n.Tok2 != nil:
		return n.Tok2

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *Ident) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Tok2 != nil {
		ret = append(ret, n.Tok2)
	}

	return ret
}

func (n *Ident) Inspect(f func(Node) bool) {

}

func (n *Ident) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *Ident) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *IfStmt) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.LParen != nil:
		return n.LParen

	case n.Cond != nil:
		return n.Cond.FirstTok()

	case n.RParen != nil:
		return n.RParen

	case n.Then != nil:
		return n.Then.FirstTok()

	case n.ElseTok != nil:
		return n.ElseTok

	case n.Else != nil:
		return n.Else.FirstTok()

	default:
		return nil
	}
}

func (n *IfStmt) LastTok() Token {
	switch {

	case n.Else != nil:
		return n.Else.LastTok()

	case n.ElseTok != nil:
		return n.ElseTok

	case n.Then != nil:
		return n.Then.LastTok()

	case n.RParen != nil:
		return n.RParen

	case n.Cond != nil:
		return n.Cond.LastTok()

	case n.LParen != nil:
		return n.LParen

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *IfStmt) Children() []Node {
	ret := make([]Node, 0, 7)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.LParen != nil {
		ret = append(ret, n.LParen)
	}

	if n.Cond != nil {
		ret = append(ret, n.Cond)
	}

	if n.RParen != nil {
		ret = append(ret, n.RParen)
	}

	if n.Then != nil {
		ret = append(ret, n.Then)
	}

	if n.ElseTok != nil {
		ret = append(ret, n.ElseTok)
	}

	if n.Else != nil {
		ret = append(ret, n.Else)
	}

	return ret
}

func (n *IfStmt) Inspect(f func(Node) bool) {

	if c := n.Cond; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Then; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Else; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *IfStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *IfStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ImportDecl) FirstTok() Token {
	switch {

	case n.ImportTok != nil:
		return n.ImportTok

	case n.FromTok != nil:
		return n.FromTok

	case n.Module != nil:
		return n.Module.FirstTok()

	case n.Language != nil:
		return n.Language.FirstTok()

	case n.LBrace != nil:
		return n.LBrace

	case len(n.List) > 0:
		return n.List[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *ImportDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.RBrace != nil:
		return n.RBrace

	case len(n.List) > 0:
		return n.List[len(n.List)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.Language != nil:
		return n.Language.LastTok()

	case n.Module != nil:
		return n.Module.LastTok()

	case n.FromTok != nil:
		return n.FromTok

	case n.ImportTok != nil:
		return n.ImportTok

	default:
		return nil
	}
}

func (n *ImportDecl) Children() []Node {
	ret := make([]Node, 0, 8)

	if n.ImportTok != nil {
		ret = append(ret, n.ImportTok)
	}

	if n.FromTok != nil {
		ret = append(ret, n.FromTok)
	}

	if n.Module != nil {
		ret = append(ret, n.Module)
	}

	if n.Language != nil {
		ret = append(ret, n.Language)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.List {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *ImportDecl) Inspect(f func(Node) bool) {

	if c := n.Module; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Language; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.List {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ImportDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ImportDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *IndexExpr) FirstTok() Token {
	switch {

	case n.X != nil:
		return n.X.FirstTok()

	case n.LBrack != nil:
		return n.LBrack

	case n.Index != nil:
		return n.Index.FirstTok()

	case n.RBrack != nil:
		return n.RBrack

	default:
		return nil
	}
}

func (n *IndexExpr) LastTok() Token {
	switch {

	case n.RBrack != nil:
		return n.RBrack

	case n.Index != nil:
		return n.Index.LastTok()

	case n.LBrack != nil:
		return n.LBrack

	case n.X != nil:
		return n.X.LastTok()

	default:
		return nil
	}
}

func (n *IndexExpr) Children() []Node {
	ret := make([]Node, 0, 4)

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.LBrack != nil {
		ret = append(ret, n.LBrack)
	}

	if n.Index != nil {
		ret = append(ret, n.Index)
	}

	if n.RBrack != nil {
		ret = append(ret, n.RBrack)
	}

	return ret
}

func (n *IndexExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Index; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *IndexExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *IndexExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *LanguageSpec) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case len(n.List) > 0:
		return n.List[0].FirstTok()

	default:
		return nil
	}
}

func (n *LanguageSpec) LastTok() Token {
	switch {

	case len(n.List) > 0:
		return n.List[len(n.List)-1].LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *LanguageSpec) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	for _, c := range n.List {
		ret = append(ret, c)
	}

	return ret
}

func (n *LanguageSpec) Inspect(f func(Node) bool) {

	for _, c := range n.List {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *LanguageSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *LanguageSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *LengthExpr) FirstTok() Token {
	switch {

	case n.X != nil:
		return n.X.FirstTok()

	case n.Len != nil:
		return n.Len

	case n.Size != nil:
		return n.Size.FirstTok()

	default:
		return nil
	}
}

func (n *LengthExpr) LastTok() Token {
	switch {

	case n.Size != nil:
		return n.Size.LastTok()

	case n.Len != nil:
		return n.Len

	case n.X != nil:
		return n.X.LastTok()

	default:
		return nil
	}
}

func (n *LengthExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.Len != nil {
		ret = append(ret, n.Len)
	}

	if n.Size != nil {
		ret = append(ret, n.Size)
	}

	return ret
}

func (n *LengthExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Size; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *LengthExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *LengthExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ListSpec) FirstTok() Token {
	switch {

	case n.Kind != nil:
		return n.Kind

	case n.Length != nil:
		return n.Length.FirstTok()

	case n.OfTok != nil:
		return n.OfTok

	case n.ElemType != nil:
		return n.ElemType.FirstTok()

	default:
		return nil
	}
}

func (n *ListSpec) LastTok() Token {
	switch {

	case n.ElemType != nil:
		return n.ElemType.LastTok()

	case n.OfTok != nil:
		return n.OfTok

	case n.Length != nil:
		return n.Length.LastTok()

	case n.Kind != nil:
		return n.Kind

	default:
		return nil
	}
}

func (n *ListSpec) Children() []Node {
	ret := make([]Node, 0, 4)

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.Length != nil {
		ret = append(ret, n.Length)
	}

	if n.OfTok != nil {
		ret = append(ret, n.OfTok)
	}

	if n.ElemType != nil {
		ret = append(ret, n.ElemType)
	}

	return ret
}

func (n *ListSpec) Inspect(f func(Node) bool) {

	if c := n.Length; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.ElemType; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ListSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ListSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *MapSpec) FirstTok() Token {
	switch {

	case n.MapTok != nil:
		return n.MapTok

	case n.FromTok != nil:
		return n.FromTok

	case n.FromType != nil:
		return n.FromType.FirstTok()

	case n.ToTok != nil:
		return n.ToTok

	case n.ToType != nil:
		return n.ToType.FirstTok()

	default:
		return nil
	}
}

func (n *MapSpec) LastTok() Token {
	switch {

	case n.ToType != nil:
		return n.ToType.LastTok()

	case n.ToTok != nil:
		return n.ToTok

	case n.FromType != nil:
		return n.FromType.LastTok()

	case n.FromTok != nil:
		return n.FromTok

	case n.MapTok != nil:
		return n.MapTok

	default:
		return nil
	}
}

func (n *MapSpec) Children() []Node {
	ret := make([]Node, 0, 5)

	if n.MapTok != nil {
		ret = append(ret, n.MapTok)
	}

	if n.FromTok != nil {
		ret = append(ret, n.FromTok)
	}

	if n.FromType != nil {
		ret = append(ret, n.FromType)
	}

	if n.ToTok != nil {
		ret = append(ret, n.ToTok)
	}

	if n.ToType != nil {
		ret = append(ret, n.ToType)
	}

	return ret
}

func (n *MapSpec) Inspect(f func(Node) bool) {

	if c := n.FromType; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.ToType; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *MapSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *MapSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *MapTypeDecl) FirstTok() Token {
	switch {

	case n.TypeTok != nil:
		return n.TypeTok

	case n.Spec != nil:
		return n.Spec.FirstTok()

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.TypePars != nil:
		return n.TypePars.FirstTok()

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *MapTypeDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.TypePars != nil:
		return n.TypePars.LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Spec != nil:
		return n.Spec.LastTok()

	case n.TypeTok != nil:
		return n.TypeTok

	default:
		return nil
	}
}

func (n *MapTypeDecl) Children() []Node {
	ret := make([]Node, 0, 5)

	if n.TypeTok != nil {
		ret = append(ret, n.TypeTok)
	}

	if n.Spec != nil {
		ret = append(ret, n.Spec)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.TypePars != nil {
		ret = append(ret, n.TypePars)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *MapTypeDecl) Inspect(f func(Node) bool) {

	if c := n.Spec; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.TypePars; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *MapTypeDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *MapTypeDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ModifiesExpr) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.X != nil:
		return n.X.FirstTok()

	case n.Assign != nil:
		return n.Assign

	case n.Y != nil:
		return n.Y.FirstTok()

	default:
		return nil
	}
}

func (n *ModifiesExpr) LastTok() Token {
	switch {

	case n.Y != nil:
		return n.Y.LastTok()

	case n.Assign != nil:
		return n.Assign

	case n.X != nil:
		return n.X.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *ModifiesExpr) Children() []Node {
	ret := make([]Node, 0, 4)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.Assign != nil {
		ret = append(ret, n.Assign)
	}

	if n.Y != nil {
		ret = append(ret, n.Y)
	}

	return ret
}

func (n *ModifiesExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Y; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ModifiesExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ModifiesExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *Module) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.Language != nil:
		return n.Language.FirstTok()

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Defs) > 0:
		return n.Defs[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *Module) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Defs) > 0:
		return n.Defs[len(n.Defs)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.Language != nil:
		return n.Language.LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *Module) Children() []Node {
	ret := make([]Node, 0, 7)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.Language != nil {
		ret = append(ret, n.Language)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Defs {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *Module) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Language; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Defs {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *Module) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *Module) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ModuleDef) FirstTok() Token {
	switch {

	case n.Visibility != nil:
		return n.Visibility

	case n.Def != nil:
		return n.Def.FirstTok()

	default:
		return nil
	}
}

func (n *ModuleDef) LastTok() Token {
	switch {

	case n.Def != nil:
		return n.Def.LastTok()

	case n.Visibility != nil:
		return n.Visibility

	default:
		return nil
	}
}

func (n *ModuleDef) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Visibility != nil {
		ret = append(ret, n.Visibility)
	}

	if n.Def != nil {
		ret = append(ret, n.Def)
	}

	return ret
}

func (n *ModuleDef) Inspect(f func(Node) bool) {

	if c := n.Def; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ModuleDef) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ModuleDef) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ModuleParameterGroup) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Decls) > 0:
		return n.Decls[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *ModuleParameterGroup) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Decls) > 0:
		return n.Decls[len(n.Decls)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *ModuleParameterGroup) Children() []Node {
	ret := make([]Node, 0, 5)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Decls {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *ModuleParameterGroup) Inspect(f func(Node) bool) {

	for _, c := range n.Decls {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ModuleParameterGroup) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ModuleParameterGroup) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *MtcSpec) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Comp != nil:
		return n.Comp.FirstTok()

	default:
		return nil
	}
}

func (n *MtcSpec) LastTok() Token {
	switch {

	case n.Comp != nil:
		return n.Comp.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *MtcSpec) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Comp != nil {
		ret = append(ret, n.Comp)
	}

	return ret
}

func (n *MtcSpec) Inspect(f func(Node) bool) {

	if c := n.Comp; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *MtcSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *MtcSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *NodeList) FirstTok() Token {
	switch {

	case len(n.Nodes) > 0:
		return n.Nodes[0].FirstTok()

	default:
		return nil
	}
}

func (n *NodeList) LastTok() Token {
	switch {

	case len(n.Nodes) > 0:
		return n.Nodes[len(n.Nodes)-1].LastTok()

	default:
		return nil
	}
}

func (n *NodeList) Children() []Node {
	ret := make([]Node, 0, 1)

	for _, c := range n.Nodes {
		ret = append(ret, c)
	}

	return ret
}

func (n *NodeList) Inspect(f func(Node) bool) {

	for _, c := range n.Nodes {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *NodeList) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *NodeList) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ParamExpr) FirstTok() Token {
	switch {

	case n.X != nil:
		return n.X.FirstTok()

	case n.Tok != nil:
		return n.Tok

	case n.Y != nil:
		return n.Y.FirstTok()

	default:
		return nil
	}
}

func (n *ParamExpr) LastTok() Token {
	switch {

	case n.Y != nil:
		return n.Y.LastTok()

	case n.Tok != nil:
		return n.Tok

	case n.X != nil:
		return n.X.LastTok()

	default:
		return nil
	}
}

func (n *ParamExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Y != nil {
		ret = append(ret, n.Y)
	}

	return ret
}

func (n *ParamExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Y; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ParamExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ParamExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ParametrizedIdent) FirstTok() Token {
	switch {

	case n.Ident != nil:
		return n.Ident.FirstTok()

	case n.Params != nil:
		return n.Params.FirstTok()

	default:
		return nil
	}
}

func (n *ParametrizedIdent) LastTok() Token {
	switch {

	case n.Params != nil:
		return n.Params.LastTok()

	case n.Ident != nil:
		return n.Ident.LastTok()

	default:
		return nil
	}
}

func (n *ParametrizedIdent) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Ident != nil {
		ret = append(ret, n.Ident)
	}

	if n.Params != nil {
		ret = append(ret, n.Params)
	}

	return ret
}

func (n *ParametrizedIdent) Inspect(f func(Node) bool) {

	if c := n.Ident; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Params; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ParametrizedIdent) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ParametrizedIdent) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ParenExpr) FirstTok() Token {
	switch {

	case n.LParen != nil:
		return n.LParen

	case len(n.List) > 0:
		return n.List[0].FirstTok()

	case n.RParen != nil:
		return n.RParen

	default:
		return nil
	}
}

func (n *ParenExpr) LastTok() Token {
	switch {

	case n.RParen != nil:
		return n.RParen

	case len(n.List) > 0:
		return n.List[len(n.List)-1].LastTok()

	case n.LParen != nil:
		return n.LParen

	default:
		return nil
	}
}

func (n *ParenExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.LParen != nil {
		ret = append(ret, n.LParen)
	}

	for _, c := range n.List {
		ret = append(ret, c)
	}

	if n.RParen != nil {
		ret = append(ret, n.RParen)
	}

	return ret
}

func (n *ParenExpr) Inspect(f func(Node) bool) {

	for _, c := range n.List {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ParenExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ParenExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *PatternExpr) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.NoCase != nil:
		return n.NoCase

	case n.X != nil:
		return n.X.FirstTok()

	default:
		return nil
	}
}

func (n *PatternExpr) LastTok() Token {
	switch {

	case n.X != nil:
		return n.X.LastTok()

	case n.NoCase != nil:
		return n.NoCase

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *PatternExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.NoCase != nil {
		ret = append(ret, n.NoCase)
	}

	if n.X != nil {
		ret = append(ret, n.X)
	}

	return ret
}

func (n *PatternExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *PatternExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *PatternExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *PortAttribute) FirstTok() Token {
	switch {

	case n.Kind != nil:
		return n.Kind

	case len(n.Types) > 0:
		return n.Types[0].FirstTok()

	default:
		return nil
	}
}

func (n *PortAttribute) LastTok() Token {
	switch {

	case len(n.Types) > 0:
		return n.Types[len(n.Types)-1].LastTok()

	case n.Kind != nil:
		return n.Kind

	default:
		return nil
	}
}

func (n *PortAttribute) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	for _, c := range n.Types {
		ret = append(ret, c)
	}

	return ret
}

func (n *PortAttribute) Inspect(f func(Node) bool) {

	for _, c := range n.Types {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *PortAttribute) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *PortAttribute) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *PortMapAttribute) FirstTok() Token {
	switch {

	case n.MapTok != nil:
		return n.MapTok

	case n.ParamTok != nil:
		return n.ParamTok

	case n.Params != nil:
		return n.Params.FirstTok()

	default:
		return nil
	}
}

func (n *PortMapAttribute) LastTok() Token {
	switch {

	case n.Params != nil:
		return n.Params.LastTok()

	case n.ParamTok != nil:
		return n.ParamTok

	case n.MapTok != nil:
		return n.MapTok

	default:
		return nil
	}
}

func (n *PortMapAttribute) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.MapTok != nil {
		ret = append(ret, n.MapTok)
	}

	if n.ParamTok != nil {
		ret = append(ret, n.ParamTok)
	}

	if n.Params != nil {
		ret = append(ret, n.Params)
	}

	return ret
}

func (n *PortMapAttribute) Inspect(f func(Node) bool) {

	if c := n.Params; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *PortMapAttribute) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *PortMapAttribute) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *PortTypeDecl) FirstTok() Token {
	switch {

	case n.TypeTok != nil:
		return n.TypeTok

	case n.PortTok != nil:
		return n.PortTok

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.TypePars != nil:
		return n.TypePars.FirstTok()

	case n.Kind != nil:
		return n.Kind

	case n.Realtime != nil:
		return n.Realtime

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Attrs) > 0:
		return n.Attrs[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *PortTypeDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Attrs) > 0:
		return n.Attrs[len(n.Attrs)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.Realtime != nil:
		return n.Realtime

	case n.Kind != nil:
		return n.Kind

	case n.TypePars != nil:
		return n.TypePars.LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.PortTok != nil:
		return n.PortTok

	case n.TypeTok != nil:
		return n.TypeTok

	default:
		return nil
	}
}

func (n *PortTypeDecl) Children() []Node {
	ret := make([]Node, 0, 10)

	if n.TypeTok != nil {
		ret = append(ret, n.TypeTok)
	}

	if n.PortTok != nil {
		ret = append(ret, n.PortTok)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.TypePars != nil {
		ret = append(ret, n.TypePars)
	}

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.Realtime != nil {
		ret = append(ret, n.Realtime)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Attrs {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *PortTypeDecl) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.TypePars; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Attrs {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *PortTypeDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *PortTypeDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *PostExpr) FirstTok() Token {
	switch {

	case n.X != nil:
		return n.X.FirstTok()

	case n.Op != nil:
		return n.Op

	default:
		return nil
	}
}

func (n *PostExpr) LastTok() Token {
	switch {

	case n.Op != nil:
		return n.Op

	case n.X != nil:
		return n.X.LastTok()

	default:
		return nil
	}
}

func (n *PostExpr) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.Op != nil {
		ret = append(ret, n.Op)
	}

	return ret
}

func (n *PostExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *PostExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *PostExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *RedirectExpr) FirstTok() Token {
	switch {

	case n.X != nil:
		return n.X.FirstTok()

	case n.Tok != nil:
		return n.Tok

	case n.ValueTok != nil:
		return n.ValueTok

	case len(n.Value) > 0:
		return n.Value[0].FirstTok()

	case n.ParamTok != nil:
		return n.ParamTok

	case len(n.Param) > 0:
		return n.Param[0].FirstTok()

	case n.SenderTok != nil:
		return n.SenderTok

	case n.Sender != nil:
		return n.Sender.FirstTok()

	case n.IndexTok != nil:
		return n.IndexTok

	case n.IndexValueTok != nil:
		return n.IndexValueTok

	case n.Index != nil:
		return n.Index.FirstTok()

	case n.TimestampTok != nil:
		return n.TimestampTok

	case n.Timestamp != nil:
		return n.Timestamp.FirstTok()

	default:
		return nil
	}
}

func (n *RedirectExpr) LastTok() Token {
	switch {

	case n.Timestamp != nil:
		return n.Timestamp.LastTok()

	case n.TimestampTok != nil:
		return n.TimestampTok

	case n.Index != nil:
		return n.Index.LastTok()

	case n.IndexValueTok != nil:
		return n.IndexValueTok

	case n.IndexTok != nil:
		return n.IndexTok

	case n.Sender != nil:
		return n.Sender.LastTok()

	case n.SenderTok != nil:
		return n.SenderTok

	case len(n.Param) > 0:
		return n.Param[len(n.Param)-1].LastTok()

	case n.ParamTok != nil:
		return n.ParamTok

	case len(n.Value) > 0:
		return n.Value[len(n.Value)-1].LastTok()

	case n.ValueTok != nil:
		return n.ValueTok

	case n.Tok != nil:
		return n.Tok

	case n.X != nil:
		return n.X.LastTok()

	default:
		return nil
	}
}

func (n *RedirectExpr) Children() []Node {
	ret := make([]Node, 0, 13)

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.ValueTok != nil {
		ret = append(ret, n.ValueTok)
	}

	for _, c := range n.Value {
		ret = append(ret, c)
	}

	if n.ParamTok != nil {
		ret = append(ret, n.ParamTok)
	}

	for _, c := range n.Param {
		ret = append(ret, c)
	}

	if n.SenderTok != nil {
		ret = append(ret, n.SenderTok)
	}

	if n.Sender != nil {
		ret = append(ret, n.Sender)
	}

	if n.IndexTok != nil {
		ret = append(ret, n.IndexTok)
	}

	if n.IndexValueTok != nil {
		ret = append(ret, n.IndexValueTok)
	}

	if n.Index != nil {
		ret = append(ret, n.Index)
	}

	if n.TimestampTok != nil {
		ret = append(ret, n.TimestampTok)
	}

	if n.Timestamp != nil {
		ret = append(ret, n.Timestamp)
	}

	return ret
}

func (n *RedirectExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Value {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Param {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Sender; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Index; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Timestamp; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *RedirectExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *RedirectExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *RefSpec) FirstTok() Token {
	switch {

	case n.X != nil:
		return n.X.FirstTok()

	default:
		return nil
	}
}

func (n *RefSpec) LastTok() Token {
	switch {

	case n.X != nil:
		return n.X.LastTok()

	default:
		return nil
	}
}

func (n *RefSpec) Children() []Node {
	ret := make([]Node, 0, 1)

	if n.X != nil {
		ret = append(ret, n.X)
	}

	return ret
}

func (n *RefSpec) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *RefSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *RefSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *RegexpExpr) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.NoCase != nil:
		return n.NoCase

	case n.X != nil:
		return n.X.FirstTok()

	default:
		return nil
	}
}

func (n *RegexpExpr) LastTok() Token {
	switch {

	case n.X != nil:
		return n.X.LastTok()

	case n.NoCase != nil:
		return n.NoCase

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *RegexpExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.NoCase != nil {
		ret = append(ret, n.NoCase)
	}

	if n.X != nil {
		ret = append(ret, n.X)
	}

	return ret
}

func (n *RegexpExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *RegexpExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *RegexpExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *RestrictionSpec) FirstTok() Token {
	switch {

	case n.TemplateTok != nil:
		return n.TemplateTok

	case n.LParen != nil:
		return n.LParen

	case n.Tok != nil:
		return n.Tok

	case n.RParen != nil:
		return n.RParen

	default:
		return nil
	}
}

func (n *RestrictionSpec) LastTok() Token {
	switch {

	case n.RParen != nil:
		return n.RParen

	case n.Tok != nil:
		return n.Tok

	case n.LParen != nil:
		return n.LParen

	case n.TemplateTok != nil:
		return n.TemplateTok

	default:
		return nil
	}
}

func (n *RestrictionSpec) Children() []Node {
	ret := make([]Node, 0, 4)

	if n.TemplateTok != nil {
		ret = append(ret, n.TemplateTok)
	}

	if n.LParen != nil {
		ret = append(ret, n.LParen)
	}

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.RParen != nil {
		ret = append(ret, n.RParen)
	}

	return ret
}

func (n *RestrictionSpec) Inspect(f func(Node) bool) {

}

func (n *RestrictionSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *RestrictionSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ReturnSpec) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Restriction != nil:
		return n.Restriction.FirstTok()

	case n.Modif != nil:
		return n.Modif

	case n.Type != nil:
		return n.Type.FirstTok()

	default:
		return nil
	}
}

func (n *ReturnSpec) LastTok() Token {
	switch {

	case n.Type != nil:
		return n.Type.LastTok()

	case n.Modif != nil:
		return n.Modif

	case n.Restriction != nil:
		return n.Restriction.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *ReturnSpec) Children() []Node {
	ret := make([]Node, 0, 4)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Restriction != nil {
		ret = append(ret, n.Restriction)
	}

	if n.Modif != nil {
		ret = append(ret, n.Modif)
	}

	if n.Type != nil {
		ret = append(ret, n.Type)
	}

	return ret
}

func (n *ReturnSpec) Inspect(f func(Node) bool) {

	if c := n.Restriction; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Type; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ReturnSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ReturnSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ReturnStmt) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Result != nil:
		return n.Result.FirstTok()

	default:
		return nil
	}
}

func (n *ReturnStmt) LastTok() Token {
	switch {

	case n.Result != nil:
		return n.Result.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *ReturnStmt) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Result != nil {
		ret = append(ret, n.Result)
	}

	return ret
}

func (n *ReturnStmt) Inspect(f func(Node) bool) {

	if c := n.Result; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ReturnStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ReturnStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *Root) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *Root) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *RunsOnSpec) FirstTok() Token {
	switch {

	case n.RunsTok != nil:
		return n.RunsTok

	case n.OnTok != nil:
		return n.OnTok

	case n.Comp != nil:
		return n.Comp.FirstTok()

	default:
		return nil
	}
}

func (n *RunsOnSpec) LastTok() Token {
	switch {

	case n.Comp != nil:
		return n.Comp.LastTok()

	case n.OnTok != nil:
		return n.OnTok

	case n.RunsTok != nil:
		return n.RunsTok

	default:
		return nil
	}
}

func (n *RunsOnSpec) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.RunsTok != nil {
		ret = append(ret, n.RunsTok)
	}

	if n.OnTok != nil {
		ret = append(ret, n.OnTok)
	}

	if n.Comp != nil {
		ret = append(ret, n.Comp)
	}

	return ret
}

func (n *RunsOnSpec) Inspect(f func(Node) bool) {

	if c := n.Comp; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *RunsOnSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *RunsOnSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *SelectStmt) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Union != nil:
		return n.Union

	case n.Tag != nil:
		return n.Tag.FirstTok()

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Body) > 0:
		return n.Body[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	default:
		return nil
	}
}

func (n *SelectStmt) LastTok() Token {
	switch {

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Body) > 0:
		return n.Body[len(n.Body)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.Tag != nil:
		return n.Tag.LastTok()

	case n.Union != nil:
		return n.Union

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *SelectStmt) Children() []Node {
	ret := make([]Node, 0, 6)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Union != nil {
		ret = append(ret, n.Union)
	}

	if n.Tag != nil {
		ret = append(ret, n.Tag)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Body {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	return ret
}

func (n *SelectStmt) Inspect(f func(Node) bool) {

	if c := n.Tag; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Body {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *SelectStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *SelectStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *SelectorExpr) FirstTok() Token {
	switch {

	case n.X != nil:
		return n.X.FirstTok()

	case n.Dot != nil:
		return n.Dot

	case n.Sel != nil:
		return n.Sel.FirstTok()

	default:
		return nil
	}
}

func (n *SelectorExpr) LastTok() Token {
	switch {

	case n.Sel != nil:
		return n.Sel.LastTok()

	case n.Dot != nil:
		return n.Dot

	case n.X != nil:
		return n.X.LastTok()

	default:
		return nil
	}
}

func (n *SelectorExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.Dot != nil {
		ret = append(ret, n.Dot)
	}

	if n.Sel != nil {
		ret = append(ret, n.Sel)
	}

	return ret
}

func (n *SelectorExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Sel; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *SelectorExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *SelectorExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *SignatureDecl) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.TypePars != nil:
		return n.TypePars.FirstTok()

	case n.Params != nil:
		return n.Params.FirstTok()

	case n.NoBlock != nil:
		return n.NoBlock

	case n.Return != nil:
		return n.Return.FirstTok()

	case n.ExceptionTok != nil:
		return n.ExceptionTok

	case n.Exception != nil:
		return n.Exception.FirstTok()

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *SignatureDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.Exception != nil:
		return n.Exception.LastTok()

	case n.ExceptionTok != nil:
		return n.ExceptionTok

	case n.Return != nil:
		return n.Return.LastTok()

	case n.NoBlock != nil:
		return n.NoBlock

	case n.Params != nil:
		return n.Params.LastTok()

	case n.TypePars != nil:
		return n.TypePars.LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *SignatureDecl) Children() []Node {
	ret := make([]Node, 0, 9)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.TypePars != nil {
		ret = append(ret, n.TypePars)
	}

	if n.Params != nil {
		ret = append(ret, n.Params)
	}

	if n.NoBlock != nil {
		ret = append(ret, n.NoBlock)
	}

	if n.Return != nil {
		ret = append(ret, n.Return)
	}

	if n.ExceptionTok != nil {
		ret = append(ret, n.ExceptionTok)
	}

	if n.Exception != nil {
		ret = append(ret, n.Exception)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *SignatureDecl) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.TypePars; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Params; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Return; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Exception; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *SignatureDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *SignatureDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *StructSpec) FirstTok() Token {
	switch {

	case n.Kind != nil:
		return n.Kind

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Fields) > 0:
		return n.Fields[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	default:
		return nil
	}
}

func (n *StructSpec) LastTok() Token {
	switch {

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Fields) > 0:
		return n.Fields[len(n.Fields)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.Kind != nil:
		return n.Kind

	default:
		return nil
	}
}

func (n *StructSpec) Children() []Node {
	ret := make([]Node, 0, 4)

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Fields {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	return ret
}

func (n *StructSpec) Inspect(f func(Node) bool) {

	for _, c := range n.Fields {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *StructSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *StructSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *StructTypeDecl) FirstTok() Token {
	switch {

	case n.TypeTok != nil:
		return n.TypeTok

	case n.Kind != nil:
		return n.Kind

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.TypePars != nil:
		return n.TypePars.FirstTok()

	case n.LBrace != nil:
		return n.LBrace

	case len(n.Fields) > 0:
		return n.Fields[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *StructTypeDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.RBrace != nil:
		return n.RBrace

	case len(n.Fields) > 0:
		return n.Fields[len(n.Fields)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.TypePars != nil:
		return n.TypePars.LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Kind != nil:
		return n.Kind

	case n.TypeTok != nil:
		return n.TypeTok

	default:
		return nil
	}
}

func (n *StructTypeDecl) Children() []Node {
	ret := make([]Node, 0, 8)

	if n.TypeTok != nil {
		ret = append(ret, n.TypeTok)
	}

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.TypePars != nil {
		ret = append(ret, n.TypePars)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.Fields {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *StructTypeDecl) Inspect(f func(Node) bool) {

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.TypePars; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Fields {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *StructTypeDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *StructTypeDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *SubTypeDecl) FirstTok() Token {
	switch {

	case n.TypeTok != nil:
		return n.TypeTok

	case n.Field != nil:
		return n.Field.FirstTok()

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *SubTypeDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.Field != nil:
		return n.Field.LastTok()

	case n.TypeTok != nil:
		return n.TypeTok

	default:
		return nil
	}
}

func (n *SubTypeDecl) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.TypeTok != nil {
		ret = append(ret, n.TypeTok)
	}

	if n.Field != nil {
		ret = append(ret, n.Field)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *SubTypeDecl) Inspect(f func(Node) bool) {

	if c := n.Field; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *SubTypeDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *SubTypeDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *SystemSpec) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.Comp != nil:
		return n.Comp.FirstTok()

	default:
		return nil
	}
}

func (n *SystemSpec) LastTok() Token {
	switch {

	case n.Comp != nil:
		return n.Comp.LastTok()

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *SystemSpec) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Comp != nil {
		ret = append(ret, n.Comp)
	}

	return ret
}

func (n *SystemSpec) Inspect(f func(Node) bool) {

	if c := n.Comp; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *SystemSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *SystemSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *TemplateDecl) FirstTok() Token {
	switch {

	case n.RestrictionSpec != nil:
		return n.RestrictionSpec.FirstTok()

	case n.Modif != nil:
		return n.Modif

	case n.Type != nil:
		return n.Type.FirstTok()

	case n.Name != nil:
		return n.Name.FirstTok()

	case n.TypePars != nil:
		return n.TypePars.FirstTok()

	case n.Params != nil:
		return n.Params.FirstTok()

	case n.ModifiesTok != nil:
		return n.ModifiesTok

	case n.Base != nil:
		return n.Base.FirstTok()

	case n.AssignTok != nil:
		return n.AssignTok

	case n.Value != nil:
		return n.Value.FirstTok()

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *TemplateDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case n.Value != nil:
		return n.Value.LastTok()

	case n.AssignTok != nil:
		return n.AssignTok

	case n.Base != nil:
		return n.Base.LastTok()

	case n.ModifiesTok != nil:
		return n.ModifiesTok

	case n.Params != nil:
		return n.Params.LastTok()

	case n.TypePars != nil:
		return n.TypePars.LastTok()

	case n.Name != nil:
		return n.Name.LastTok()

	case n.Type != nil:
		return n.Type.LastTok()

	case n.Modif != nil:
		return n.Modif

	case n.RestrictionSpec != nil:
		return n.RestrictionSpec.LastTok()

	default:
		return nil
	}
}

func (n *TemplateDecl) Children() []Node {
	ret := make([]Node, 0, 11)

	if n.RestrictionSpec != nil {
		ret = append(ret, n.RestrictionSpec)
	}

	if n.Modif != nil {
		ret = append(ret, n.Modif)
	}

	if n.Type != nil {
		ret = append(ret, n.Type)
	}

	if n.Name != nil {
		ret = append(ret, n.Name)
	}

	if n.TypePars != nil {
		ret = append(ret, n.TypePars)
	}

	if n.Params != nil {
		ret = append(ret, n.Params)
	}

	if n.ModifiesTok != nil {
		ret = append(ret, n.ModifiesTok)
	}

	if n.Base != nil {
		ret = append(ret, n.Base)
	}

	if n.AssignTok != nil {
		ret = append(ret, n.AssignTok)
	}

	if n.Value != nil {
		ret = append(ret, n.Value)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *TemplateDecl) Inspect(f func(Node) bool) {

	if c := n.RestrictionSpec; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Type; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Name; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.TypePars; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Params; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Base; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Value; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *TemplateDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *TemplateDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *UnaryExpr) FirstTok() Token {
	switch {

	case n.Op != nil:
		return n.Op

	case n.X != nil:
		return n.X.FirstTok()

	default:
		return nil
	}
}

func (n *UnaryExpr) LastTok() Token {
	switch {

	case n.X != nil:
		return n.X.LastTok()

	case n.Op != nil:
		return n.Op

	default:
		return nil
	}
}

func (n *UnaryExpr) Children() []Node {
	ret := make([]Node, 0, 2)

	if n.Op != nil {
		ret = append(ret, n.Op)
	}

	if n.X != nil {
		ret = append(ret, n.X)
	}

	return ret
}

func (n *UnaryExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *UnaryExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *UnaryExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ValueDecl) FirstTok() Token {
	switch {

	case n.Kind != nil:
		return n.Kind

	case n.TemplateRestriction != nil:
		return n.TemplateRestriction.FirstTok()

	case n.Modif != nil:
		return n.Modif

	case n.Type != nil:
		return n.Type.FirstTok()

	case len(n.Decls) > 0:
		return n.Decls[0].FirstTok()

	case n.With != nil:
		return n.With.FirstTok()

	default:
		return nil
	}
}

func (n *ValueDecl) LastTok() Token {
	switch {

	case n.With != nil:
		return n.With.LastTok()

	case len(n.Decls) > 0:
		return n.Decls[len(n.Decls)-1].LastTok()

	case n.Type != nil:
		return n.Type.LastTok()

	case n.Modif != nil:
		return n.Modif

	case n.TemplateRestriction != nil:
		return n.TemplateRestriction.LastTok()

	case n.Kind != nil:
		return n.Kind

	default:
		return nil
	}
}

func (n *ValueDecl) Children() []Node {
	ret := make([]Node, 0, 6)

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.TemplateRestriction != nil {
		ret = append(ret, n.TemplateRestriction)
	}

	if n.Modif != nil {
		ret = append(ret, n.Modif)
	}

	if n.Type != nil {
		ret = append(ret, n.Type)
	}

	for _, c := range n.Decls {
		ret = append(ret, c)
	}

	if n.With != nil {
		ret = append(ret, n.With)
	}

	return ret
}

func (n *ValueDecl) Inspect(f func(Node) bool) {

	if c := n.TemplateRestriction; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Type; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	for _, c := range n.Decls {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.With; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ValueDecl) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ValueDecl) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ValueExpr) FirstTok() Token {
	switch {

	case n.X != nil:
		return n.X.FirstTok()

	case n.Tok != nil:
		return n.Tok

	case n.Y != nil:
		return n.Y.FirstTok()

	default:
		return nil
	}
}

func (n *ValueExpr) LastTok() Token {
	switch {

	case n.Y != nil:
		return n.Y.LastTok()

	case n.Tok != nil:
		return n.Tok

	case n.X != nil:
		return n.X.LastTok()

	default:
		return nil
	}
}

func (n *ValueExpr) Children() []Node {
	ret := make([]Node, 0, 3)

	if n.X != nil {
		ret = append(ret, n.X)
	}

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.Y != nil {
		ret = append(ret, n.Y)
	}

	return ret
}

func (n *ValueExpr) Inspect(f func(Node) bool) {

	if c := n.X; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Y; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *ValueExpr) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ValueExpr) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *ValueLiteral) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *ValueLiteral) LastTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *ValueLiteral) Children() []Node {
	ret := make([]Node, 0, 1)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	return ret
}

func (n *ValueLiteral) Inspect(f func(Node) bool) {

}

func (n *ValueLiteral) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *ValueLiteral) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *WhileStmt) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.LParen != nil:
		return n.LParen

	case n.Cond != nil:
		return n.Cond.FirstTok()

	case n.RParen != nil:
		return n.RParen

	case n.Body != nil:
		return n.Body.FirstTok()

	default:
		return nil
	}
}

func (n *WhileStmt) LastTok() Token {
	switch {

	case n.Body != nil:
		return n.Body.LastTok()

	case n.RParen != nil:
		return n.RParen

	case n.Cond != nil:
		return n.Cond.LastTok()

	case n.LParen != nil:
		return n.LParen

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *WhileStmt) Children() []Node {
	ret := make([]Node, 0, 5)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.LParen != nil {
		ret = append(ret, n.LParen)
	}

	if n.Cond != nil {
		ret = append(ret, n.Cond)
	}

	if n.RParen != nil {
		ret = append(ret, n.RParen)
	}

	if n.Body != nil {
		ret = append(ret, n.Body)
	}

	return ret
}

func (n *WhileStmt) Inspect(f func(Node) bool) {

	if c := n.Cond; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Body; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *WhileStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *WhileStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *WithSpec) FirstTok() Token {
	switch {

	case n.Tok != nil:
		return n.Tok

	case n.LBrace != nil:
		return n.LBrace

	case len(n.List) > 0:
		return n.List[0].FirstTok()

	case n.RBrace != nil:
		return n.RBrace

	default:
		return nil
	}
}

func (n *WithSpec) LastTok() Token {
	switch {

	case n.RBrace != nil:
		return n.RBrace

	case len(n.List) > 0:
		return n.List[len(n.List)-1].LastTok()

	case n.LBrace != nil:
		return n.LBrace

	case n.Tok != nil:
		return n.Tok

	default:
		return nil
	}
}

func (n *WithSpec) Children() []Node {
	ret := make([]Node, 0, 4)

	if n.Tok != nil {
		ret = append(ret, n.Tok)
	}

	if n.LBrace != nil {
		ret = append(ret, n.LBrace)
	}

	for _, c := range n.List {
		ret = append(ret, c)
	}

	if n.RBrace != nil {
		ret = append(ret, n.RBrace)
	}

	return ret
}

func (n *WithSpec) Inspect(f func(Node) bool) {

	for _, c := range n.List {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *WithSpec) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *WithSpec) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}

func (n *WithStmt) FirstTok() Token {
	switch {

	case n.Kind != nil:
		return n.Kind

	case n.Override != nil:
		return n.Override

	case n.LParen != nil:
		return n.LParen

	case len(n.List) > 0:
		return n.List[0].FirstTok()

	case n.RParen != nil:
		return n.RParen

	case n.Value != nil:
		return n.Value.FirstTok()

	default:
		return nil
	}
}

func (n *WithStmt) LastTok() Token {
	switch {

	case n.Value != nil:
		return n.Value.LastTok()

	case n.RParen != nil:
		return n.RParen

	case len(n.List) > 0:
		return n.List[len(n.List)-1].LastTok()

	case n.LParen != nil:
		return n.LParen

	case n.Override != nil:
		return n.Override

	case n.Kind != nil:
		return n.Kind

	default:
		return nil
	}
}

func (n *WithStmt) Children() []Node {
	ret := make([]Node, 0, 6)

	if n.Kind != nil {
		ret = append(ret, n.Kind)
	}

	if n.Override != nil {
		ret = append(ret, n.Override)
	}

	if n.LParen != nil {
		ret = append(ret, n.LParen)
	}

	for _, c := range n.List {
		ret = append(ret, c)
	}

	if n.RParen != nil {
		ret = append(ret, n.RParen)
	}

	if n.Value != nil {
		ret = append(ret, n.Value)
	}

	return ret
}

func (n *WithStmt) Inspect(f func(Node) bool) {

	for _, c := range n.List {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

	if c := n.Value; c != nil {
		if f(c) {
			c.Inspect(f)
		}
		f(nil)
	}

}

func (n *WithStmt) Pos() int {
	if tok := n.FirstTok(); tok != nil {
		return tok.Pos()
	}
	return -1
}

func (n *WithStmt) End() int {
	if tok := n.LastTok(); tok != nil {
		return tok.End()
	}
	return -1
}
