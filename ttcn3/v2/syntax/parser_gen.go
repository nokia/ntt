// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at 2022-10-15 18:50:39.690944031 +0200 CEST m=+0.001142623

package syntax

// this is a minimal set of keywords required to parse TTCN-3.
// Note, that the standard specifies more keywords.
var keywords = map[string]Kind{
	"address":       AddressKeyword,
	"all":           AllKeyword,
	"alt":           AltKeyword,
	"altstep":       AltstepKeyword,
	"and4b":         And4bKeyword,
	"and":           AndKeyword,
	"any":           AnyKeyword,
	"case":          CaseKeyword,
	"catch":         CatchKeyword,
	"charstring":    CharstringKeyword,
	"class":         ClassKeyword,
	"component":     ComponentKeyword,
	"configuration": ConfigurationKeyword,
	"connect":       ConnectKeyword,
	"const":         ConstKeyword,
	"control":       ControlKeyword,
	"create":        CreateKeyword,
	"display":       DisplayKeyword,
	"do":            DoKeyword,
	"else":          ElseKeyword,
	"encode":        EncodeKeyword,
	"enumerated":    EnumeratedKeyword,
	"except":        ExceptKeyword,
	"exception":     ExceptionKeyword,
	"execute":       ExecuteKeyword,
	"extends":       ExtendsKeyword,
	"extension":     ExtensionKeyword,
	"external":      ExternalKeyword,
	"finally":       FinallyKeyword,
	"for":           ForKeyword,
	"friend":        FriendKeyword,
	"from":          FromKeyword,
	"function":      FunctionKeyword,
	"goto":          GotoKeyword,
	"group":         GroupKeyword,
	"if":            IfKeyword,
	"import":        ImportKeyword,
	"in":            InKeyword,
	"inout":         InoutKeyword,
	"interleave":    InterleaveKeyword,
	"label":         LabelKeyword,
	"language":      LanguageKeyword,
	"length":        LengthKeyword,
	"map":           MapKeyword,
	"message":       MessageKeyword,
	"mod":           ModKeyword,
	"modifies":      ModifiesKeyword,
	"module":        ModuleKeyword,
	"modulepar":     ModuleparKeyword,
	"mtc":           MtcKeyword,
	"noblock":       NoblockKeyword,
	"not4b":         Not4bKeyword,
	"not":           NotKeyword,
	"null":          NullKeyword,
	"of":            OfKeyword,
	"omit":          OmitKeyword,
	"on":            OnKeyword,
	"optional":      OptionalKeyword,
	"or4b":          Or4bKeyword,
	"or":            OrKeyword,
	"out":           OutKeyword,
	"override":      OverrideKeyword,
	"param":         ParamKeyword,
	"port":          PortKeyword,
	"present":       PresentKeyword,
	"private":       PrivateKeyword,
	"procedure":     ProcedureKeyword,
	"public":        PublicKeyword,
	"realtime":      RealtimeKeyword,
	"record":        RecordKeyword,
	"rem":           RemKeyword,
	"return":        ReturnKeyword,
	"runs":          RunsKeyword,
	"select":        SelectKeyword,
	"self":          SelfKeyword,
	"set":           SetKeyword,
	"signature":     SignatureKeyword,
	"stream":        StreamKeyword,
	"system":        SystemKeyword,
	"template":      TemplateKeyword,
	"testcase":      TestcaseKeyword,
	"this":          ThisKeyword,
	"timer":         TimerKeyword,
	"to":            ToKeyword,
	"type":          TypeKeyword,
	"union":         UnionKeyword,
	"universal":     UniversalKeyword,
	"unmap":         UnmapKeyword,
	"value":         ValueKeyword,
	"var":           VarKeyword,
	"variant":       VariantKeyword,
	"while":         WhileKeyword,
	"with":          WithKeyword,
	"xor4b":         Xor4bKeyword,
	"xor":           XorKeyword,
}

// Module = "module" Name [Language] "{" { Decl ";" } "}" [With] ";".
func (p *parser) parseModule() bool {
	p.Push(Module)
	p.expect(ModuleKeyword)
	p.parseName()
	if p.accept(LanguageKeyword) {
		p.parseLanguage()
	}
	p.expect(LeftBrace)
	for p.accept(AltstepKeyword, ConfigurationKeyword, ConstKeyword, ControlKeyword, CreateKeyword, ExternalKeyword, FinallyKeyword, FriendKeyword, GroupKeyword, ImportKeyword, ModuleparKeyword, PrivateKeyword, PublicKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword, VarKeyword) {
		p.parseDecl()
		p.expect(Semicolon)
	}
	p.expect(RightBrace)
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.expect(Semicolon)
	p.Pop()
	return true
}

// Group = [Visibility] "group" Name "{" { Decl ";" } "}" [With].
func (p *parser) parseGroup() bool {
	p.Push(Group)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(GroupKeyword)
	p.parseName()
	p.expect(LeftBrace)
	for p.accept(AltstepKeyword, ConfigurationKeyword, ConstKeyword, ControlKeyword, CreateKeyword, ExternalKeyword, FinallyKeyword, FriendKeyword, GroupKeyword, ImportKeyword, ModuleparKeyword, PrivateKeyword, PublicKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword, VarKeyword) {
		p.parseDecl()
		p.expect(Semicolon)
	}
	p.expect(RightBrace)
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Friend = [Visibility] "friend" "module" Refs [With].
func (p *parser) parseFriend() bool {
	p.Push(Friend)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(FriendKeyword)
	p.expect(ModuleKeyword)
	p.parseRefs()
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Import = [Visibility] "import" "from" Ref ["->" Name] ("all" [ExceptSpec] | ImportSpec) [With].
func (p *parser) parseImport() bool {
	p.Push(Import)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(ImportKeyword)
	p.expect(FromKeyword)
	p.parseRef()
	if p.accept(Arrow) {
		p.expect(Arrow)
		p.parseName()
	}
	switch p.next {
	case AllKeyword:
		p.expect(AllKeyword)
		if p.accept(ExceptKeyword) {
			p.parseExceptSpec()
		}
	case LeftBrace:
		p.parseImportSpec()

	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// ExceptSpec = "except" "{" { ExceptStmt ";" } "}".
func (p *parser) parseExceptSpec() bool {
	p.Push(ExceptSpec)
	p.expect(ExceptKeyword)
	p.expect(LeftBrace)
	for p.accept(AltstepKeyword, ConstKeyword, FunctionKeyword, GroupKeyword, ImportKeyword, ModuleparKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword) {
		p.parseExceptStmt()
		p.expect(Semicolon)
	}
	p.expect(RightBrace)
	p.Pop()
	return true
}

// ExceptStmt = ImportKind Refs
//            | "group"    Refs
//            .
func (p *parser) parseExceptStmt() bool {
	p.Push(ExceptStmt)
	switch p.next {
	case AltstepKeyword, ConstKeyword, FunctionKeyword, ImportKeyword, ModuleparKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword:
		p.parseImportKind()

		p.parseRefs()
	case GroupKeyword:
		p.expect(GroupKeyword)
		p.parseRefs()

	}
	p.Pop()
	return true
}

// ImportSpec = "{" { ImportStmt ";" } "}".
func (p *parser) parseImportSpec() bool {
	p.Push(ImportSpec)
	p.expect(LeftBrace)
	for p.accept(AltstepKeyword, ConstKeyword, FunctionKeyword, GroupKeyword, ImportKeyword, ModuleparKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword) {
		p.parseImportStmt()
		p.expect(Semicolon)
	}
	p.expect(RightBrace)
	p.Pop()
	return true
}

// ImportKind
//     = "altstep"
//     | "const"
//     | "function"
//     | "import"
//     | "modulepar"
//     | "signature"
//     | "template"
//     | "testcase"
//     | "type"
//     .
func (p *parser) parseImportKind() bool {
	p.Push(ImportKind)
	switch p.next {
	case AltstepKeyword:
		p.expect(AltstepKeyword)
	case ConstKeyword:
		p.expect(ConstKeyword)
	case FunctionKeyword:
		p.expect(FunctionKeyword)
	case ImportKeyword:
		p.expect(ImportKeyword)
	case ModuleparKeyword:
		p.expect(ModuleparKeyword)
	case SignatureKeyword:
		p.expect(SignatureKeyword)
	case TemplateKeyword:
		p.expect(TemplateKeyword)
	case TestcaseKeyword:
		p.expect(TestcaseKeyword)
	case TypeKeyword:
		p.expect(TypeKeyword)
	}
	p.Pop()
	return true
}

// Signature = [Visibility] "signature" Name [FormalTypePars] FormalPars [Return] ["noblock"] [Exception] [With].
func (p *parser) parseSignature() bool {
	p.Push(Signature)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(SignatureKeyword)
	p.parseName()
	if p.accept(Less) {
		p.parseFormalTypePars()
	}
	p.parseFormalPars()
	if p.accept(ReturnKeyword) {
		p.parseReturn()
	}
	if p.accept(NoblockKeyword) {
		p.expect(NoblockKeyword)
	}
	if p.accept(ExceptionKeyword) {
		p.parseException()
	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Component = [Visibility] "type" "component" Name [FormalTypePars][Extends] Block [With].
func (p *parser) parseComponent() bool {
	p.Push(Component)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	p.expect(ComponentKeyword)
	p.parseName()
	if p.accept(Less) {
		p.parseFormalTypePars()
	}
	if p.accept(ExtendsKeyword) {
		p.parseExtends()
	}
	p.parseBlock()
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Port = [Visibility] "type" "port" Name PortKind {PortSpec} "{" {PortAttribute ";"} "}" [With].
func (p *parser) parsePort() bool {
	p.Push(Port)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	p.expect(PortKeyword)
	p.parseName()

	p.parsePortKind()
	for p.accept(ConnectKeyword, MapKeyword, RealtimeKeyword) {
		p.parsePortSpec()
	}
	p.expect(LeftBrace)
	for p.accept(AddressKeyword, InKeyword, InoutKeyword, MapKeyword, OutKeyword, UnmapKeyword) {
		p.parsePortAttribute()
		p.expect(Semicolon)
	}
	p.expect(RightBrace)
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// PortKind = "message"
//          | "procedure"
// 	 | "stream"
// 	 .
func (p *parser) parsePortKind() bool {
	p.Push(PortKind)
	switch p.next {
	case MessageKeyword:
		p.expect(MessageKeyword)
	case ProcedureKeyword:
		p.expect(ProcedureKeyword)
	case StreamKeyword:
		p.expect(StreamKeyword)
	}
	p.Pop()
	return true
}

// PortSpec = "realtime"
//          | "map" "to" Refs
// 	 | "connect" "to" Refs
// 	 .
func (p *parser) parsePortSpec() bool {
	p.Push(PortSpec)
	switch p.next {
	case RealtimeKeyword:
		p.expect(RealtimeKeyword)
	case MapKeyword:
		p.expect(MapKeyword)
		p.expect(ToKeyword)
		p.parseRefs()
	case ConnectKeyword:
		p.expect(ConnectKeyword)
		p.expect(ToKeyword)
		p.parseRefs()

	}
	p.Pop()
	return true
}

// PortAttribute = "map"   "param" FormalPars
//               | "unmap" "param" FormalPars
//               | "address" Ref [PortTranslation]
//               | ("in"|"out"|"inout") {PortElement ","}
//               .
func (p *parser) parsePortAttribute() bool {
	p.Push(PortAttribute)
	switch p.next {
	case MapKeyword:
		p.expect(MapKeyword)
		p.expect(ParamKeyword)
		p.parseFormalPars()
	case UnmapKeyword:
		p.expect(UnmapKeyword)
		p.expect(ParamKeyword)
		p.parseFormalPars()
	case AddressKeyword:
		p.expect(AddressKeyword)
		p.parseRef()
		if p.accept(FromKeyword, ToKeyword) {
			p.parsePortTranslation()
		}
	case InKeyword, InoutKeyword, OutKeyword:
		switch p.next {
		case InKeyword:
			p.expect(InKeyword)
		case OutKeyword:
			p.expect(OutKeyword)
		case InoutKeyword:
			p.expect(InoutKeyword)
		}
		for p.accept(AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword) {
			p.parsePortElement()
			p.expect(Comma)
		}
	}
	p.Pop()
	return true
}

// PortElement = Ref [PortTranslation].
func (p *parser) parsePortElement() bool {
	p.Push(PortElement)
	p.parseRef()
	if p.accept(FromKeyword, ToKeyword) {
		p.parsePortTranslation()
	}
	p.Pop()
	return true
}

// PortTranslation =("from"|"to") Ref "with" Ref "(" ")".
func (p *parser) parsePortTranslation() bool {
	p.Push(PortTranslation)
	switch p.next {
	case FromKeyword:
		p.expect(FromKeyword)
	case ToKeyword:
		p.expect(ToKeyword)
	}
	p.parseRef()
	p.expect(WithKeyword)
	p.parseRef()
	p.expect(LeftParen)
	p.expect(RightParen)
	p.Pop()
	return true
}

// SubType = [Visibility] "type" Ref Name [FormalTypePars] {ArrayDef} ["(" Exprs ")"] [With].
func (p *parser) parseSubType() bool {
	p.Push(SubType)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	p.parseRef()

	p.parseName()
	if p.accept(Less) {
		p.parseFormalTypePars()
	}
	for p.accept(LeftBracket) {
		p.parseArrayDef()
	}
	if p.accept(LeftParen) {
		p.expect(LeftParen)
		p.parseExprs()
		p.expect(RightParen)
	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Struct = [Visibility] "type" StructKind Name [FormalTypePars] "{" { StructMember "," } "}" [With].
func (p *parser) parseStruct() bool {
	p.Push(Struct)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	p.parseStructKind()

	p.parseName()
	if p.accept(Less) {
		p.parseFormalTypePars()
	}
	p.expect(LeftBrace)
	for p.accept(AddressKeyword, AllKeyword, AnyKeyword, AtDefault, EnumeratedKeyword, Identifier, MapKeyword, MtcKeyword, RecordKeyword, SelfKeyword, SetKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UnionKeyword, UniversalKeyword, UnmapKeyword) {
		p.parseStructMember()
		p.expect(Comma)
	}
	p.expect(RightBrace)
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// StructKind = "record" | "set" | "union".
func (p *parser) parseStructKind() bool {
	p.Push(StructKind)
	switch p.next {
	case RecordKeyword:
		p.expect(RecordKeyword)
	case SetKeyword:
		p.expect(SetKeyword)
	case UnionKeyword:
		p.expect(UnionKeyword)
	}
	p.Pop()
	return true
}

// StructMember = ["@default"] NestedType Name {ArrayDef} ["(" Exprs ")"].
func (p *parser) parseStructMember() bool {
	p.Push(StructMember)
	if p.accept(AtDefault) {
		p.expect(AtDefault)
	}
	p.parseNestedType()

	p.parseName()
	for p.accept(LeftBracket) {
		p.parseArrayDef()
	}
	if p.accept(LeftParen) {
		p.expect(LeftParen)
		p.parseExprs()
		p.expect(RightParen)
	}
	p.Pop()
	return true
}

// List = [Visibility] "type" ListKind ["length" "(" Expr ")"] "of" NestedType Name [With].
func (p *parser) parseList() bool {
	p.Push(List)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	p.parseListKind()
	if p.accept(LengthKeyword) {
		p.expect(LengthKeyword)
		p.expect(LeftParen)
		p.parseExpr()
		p.expect(RightParen)
	}
	p.expect(OfKeyword)
	p.parseNestedType()

	p.parseName()
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// ListKind = "record" | "set".
func (p *parser) parseListKind() bool {
	p.Push(ListKind)
	switch p.next {
	case RecordKeyword:
		p.expect(RecordKeyword)
	case SetKeyword:
		p.expect(SetKeyword)
	}
	p.Pop()
	return true
}

// Enum = [Visibility] "type" "enumerated" Name "{" { EnumLabel "," } "}" [With].
func (p *parser) parseEnum() bool {
	p.Push(Enum)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	p.expect(EnumeratedKeyword)
	p.parseName()
	p.expect(LeftBrace)
	for p.accept(Identifier) {
		p.parseEnumLabel()
		p.expect(Comma)
	}
	p.expect(RightBrace)
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// EnumLabel = Name ["(" Exprs ")"].
func (p *parser) parseEnumLabel() bool {
	p.Push(EnumLabel)
	p.parseName()
	if p.accept(LeftParen) {
		p.expect(LeftParen)
		p.parseExprs()
		p.expect(RightParen)
	}
	p.Pop()
	return true
}

// Map = [Visibility] "type" "map" "from" Ref "to" Ref Name [With].
func (p *parser) parseMap() bool {
	p.Push(Map)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	p.expect(MapKeyword)
	p.expect(FromKeyword)
	p.parseRef()
	p.expect(ToKeyword)
	p.parseRef()

	p.parseName()
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Class = [Visibility] "type" ["external"] "class" {modifier} Name [Extends] {ConfigSpec} "{" { Decl ";" } "}" ["finally" Block] [With].
func (p *parser) parseClass() bool {
	p.Push(Class)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	if p.accept(ExternalKeyword) {
		p.expect(ExternalKeyword)
	}
	p.expect(ClassKeyword)
	for p.accept(Modifier) {
		p.expect(Modifier)
	}
	p.parseName()
	if p.accept(ExtendsKeyword) {
		p.parseExtends()
	}
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		p.parseConfigSpec()
	}
	p.expect(LeftBrace)
	for p.accept(AltstepKeyword, ConfigurationKeyword, ConstKeyword, ControlKeyword, CreateKeyword, ExternalKeyword, FinallyKeyword, FriendKeyword, GroupKeyword, ImportKeyword, ModuleparKeyword, PrivateKeyword, PublicKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword, VarKeyword) {
		p.parseDecl()
		p.expect(Semicolon)
	}
	p.expect(RightBrace)
	if p.accept(FinallyKeyword) {
		p.expect(FinallyKeyword)
		p.parseBlock()
	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Constructor = [Visibility] "create" FormalPars ["external" FormalPars] [":" Ref "(" Exprs ")" ] [Block] .
func (p *parser) parseConstructor() bool {
	p.Push(Constructor)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(CreateKeyword)
	p.parseFormalPars()
	if p.accept(ExternalKeyword) {
		p.expect(ExternalKeyword)
		p.parseFormalPars()
	}
	if p.accept(Colon) {
		p.expect(Colon)
		p.parseRef()
		p.expect(LeftParen)
		p.parseExprs()
		p.expect(RightParen)
	}
	if p.accept(LeftBrace) {
		p.parseBlock()
	}
	p.Pop()
	return true
}

// Control = "control" Block.
func (p *parser) parseControl() bool {
	p.Push(Control)
	p.expect(ControlKeyword)
	p.parseBlock()
	p.Pop()
	return true
}

// Destructor = "finally" Block.
func (p *parser) parseDestructor() bool {
	p.Push(Destructor)
	p.expect(FinallyKeyword)
	p.parseBlock()
	p.Pop()
	return true
}

// TestcaseType = [Visibility] "type" "testcase" Name FormalPars {ConfigSpec} [With].
func (p *parser) parseTestcaseType() bool {
	p.Push(TestcaseType)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	p.expect(TestcaseKeyword)
	p.parseName()

	p.parseFormalPars()
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		p.parseConfigSpec()
	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// FunctionType = [Visibility] "type" "function" {modifier} Name FormalPars {ConfigSpec} [Return] [With].
func (p *parser) parseFunctionType() bool {
	p.Push(FunctionType)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	p.expect(FunctionKeyword)
	for p.accept(Modifier) {
		p.expect(Modifier)
	}
	p.parseName()

	p.parseFormalPars()
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		p.parseConfigSpec()
	}
	if p.accept(ReturnKeyword) {
		p.parseReturn()
	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// AltstepType = [Visibility] "type" "altstep" {modifier} ["interleave"] Name FormalPars {ConfigSpec} [With].
func (p *parser) parseAltstepType() bool {
	p.Push(AltstepType)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TypeKeyword)
	p.expect(AltstepKeyword)
	for p.accept(Modifier) {
		p.expect(Modifier)
	}
	if p.accept(InterleaveKeyword) {
		p.expect(InterleaveKeyword)
	}
	p.parseName()

	p.parseFormalPars()
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		p.parseConfigSpec()
	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// VarDecl = [Visibility] ("const"|"var"|"modulepar") [NestedTemplate] {modifier} Ref Declarator { "," Declarator} [With].
func (p *parser) parseVarDecl() bool {
	p.Push(VarDecl)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	switch p.next {
	case ConstKeyword:
		p.expect(ConstKeyword)
	case VarKeyword:
		p.expect(VarKeyword)
	case ModuleparKeyword:
		p.expect(ModuleparKeyword)
	}
	if p.accept(OmitKeyword, PresentKeyword, TemplateKeyword, ValueKeyword) {
		p.parseNestedTemplate()
	}
	for p.accept(Modifier) {
		p.expect(Modifier)
	}
	p.parseRef()

	p.parseDeclarator()
	for p.accept(Comma) {
		p.expect(Comma)
		p.parseDeclarator()
	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// TimerDecl = "timer" Declarator { "," Declarator} [With].
func (p *parser) parseTimerDecl() bool {
	p.Push(TimerDecl)
	p.expect(TimerKeyword)
	p.parseDeclarator()
	for p.accept(Comma) {
		p.expect(Comma)
		p.parseDeclarator()
	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// PortDecl = "port" Ref Declarator { "," Declarator} [With].
func (p *parser) parsePortDecl() bool {
	p.Push(PortDecl)
	p.expect(PortKeyword)
	p.parseRef()

	p.parseDeclarator()
	for p.accept(Comma) {
		p.expect(Comma)
		p.parseDeclarator()
	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Template = [Visibility] "template" [ "(" TemplateRestriction ")"] {modifier} Ref Name [FormalPars] ["modifies" Ref] ":=" Expr [With].
func (p *parser) parseTemplate() bool {
	p.Push(Template)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TemplateKeyword)
	if p.accept(LeftParen) {
		p.expect(LeftParen)
		p.parseTemplateRestriction()
		p.expect(RightParen)
	}
	for p.accept(Modifier) {
		p.expect(Modifier)
	}
	p.parseRef()

	p.parseName()
	if p.accept(LeftParen) {
		p.parseFormalPars()
	}
	if p.accept(ModifiesKeyword) {
		p.expect(ModifiesKeyword)
		p.parseRef()
	}
	p.expect(Assign)
	p.parseExpr()
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Testcase = [Visibility] "testcase" Name FormalPars {ConfigSpec} Block.
func (p *parser) parseTestcase() bool {
	p.Push(Testcase)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(TestcaseKeyword)
	p.parseName()

	p.parseFormalPars()
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		p.parseConfigSpec()
	}
	p.parseBlock()
	p.Pop()
	return true
}

// Function = [Visibility] ["external"] "function" {modifier} Name FormalPars {ConfigSpec} [Return] [Exception] [Block] [With].
func (p *parser) parseFunction() bool {
	p.Push(Function)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	if p.accept(ExternalKeyword) {
		p.expect(ExternalKeyword)
	}
	p.expect(FunctionKeyword)
	for p.accept(Modifier) {
		p.expect(Modifier)
	}
	p.parseName()

	p.parseFormalPars()
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		p.parseConfigSpec()
	}
	if p.accept(ReturnKeyword) {
		p.parseReturn()
	}
	if p.accept(ExceptionKeyword) {
		p.parseException()
	}
	if p.accept(LeftBrace) {
		p.parseBlock()
	}
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Configuration = [Visibility] "configuration" Name FormalPars {ConfigSpec} Block [With].
func (p *parser) parseConfiguration() bool {
	p.Push(Configuration)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(ConfigurationKeyword)
	p.parseName()

	p.parseFormalPars()
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		p.parseConfigSpec()
	}
	p.parseBlock()
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// Altstep = [Visibility] "altstep" {modifier} ["interleave"] Name FormalPars {ConfigSpec} Block [With].
func (p *parser) parseAltstep() bool {
	p.Push(Altstep)
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		p.parseVisibility()
	}
	p.expect(AltstepKeyword)
	for p.accept(Modifier) {
		p.expect(Modifier)
	}
	if p.accept(InterleaveKeyword) {
		p.expect(InterleaveKeyword)
	}
	p.parseName()

	p.parseFormalPars()
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		p.parseConfigSpec()
	}
	p.parseBlock()
	if p.accept(WithKeyword) {
		p.parseWith()
	}
	p.Pop()
	return true
}

// IfStmt     = "if" "(" [(AssignStmt|VarDecl) ";"] Expr ")" Block {"else" "if" "(" Expr ")" Block} ["else" Block].
func (p *parser) parseIfStmt() bool {
	p.Push(IfStmt)
	p.expect(IfKeyword)
	p.expect(LeftParen)
	if p.accept(AddressKeyword, AllKeyword, AnyKeyword, ConstKeyword, FriendKeyword, Identifier, MapKeyword, ModuleparKeyword, MtcKeyword, PrivateKeyword, PublicKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword, VarKeyword) {
		switch p.next {
		case AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword:
			p.parseAssignStmt()
		case ConstKeyword, FriendKeyword, ModuleparKeyword, PrivateKeyword, PublicKeyword, VarKeyword:
			p.parseVarDecl()

		}
		p.expect(Semicolon)
	}
	p.parseExpr()
	p.expect(RightParen)
	p.parseBlock()
	for p.accept(ElseKeyword) {
		p.expect(ElseKeyword)
		p.expect(IfKeyword)
		p.expect(LeftParen)
		p.parseExpr()
		p.expect(RightParen)
		p.parseBlock()
	}
	if p.accept(ElseKeyword) {
		p.expect(ElseKeyword)
		p.parseBlock()
	}
	p.Pop()
	return true
}

// SelectStmt = "select" ["union"|"class"] "(" Expr ")" "{" { "case" ("else"|"(" Expr ")") Block } "}".
func (p *parser) parseSelectStmt() bool {
	p.Push(SelectStmt)
	p.expect(SelectKeyword)
	if p.accept(ClassKeyword, UnionKeyword) {
		switch p.next {
		case UnionKeyword:
			p.expect(UnionKeyword)
		case ClassKeyword:
			p.expect(ClassKeyword)
		}
	}
	p.expect(LeftParen)
	p.parseExpr()
	p.expect(RightParen)
	p.expect(LeftBrace)
	for p.accept(CaseKeyword) {
		p.expect(CaseKeyword)
		switch p.next {
		case ElseKeyword:
			p.expect(ElseKeyword)
		case LeftParen:
			p.expect(LeftParen)
			p.parseExpr()
			p.expect(RightParen)
		}
		p.parseBlock()
	}
	p.expect(RightBrace)
	p.Pop()
	return true
}

// ForStmt    = "for" "(" (AssignStmt|VarDecl) ("in" Ref|";" Expr";" AssignStmt) ")" Block.
func (p *parser) parseForStmt() bool {
	p.Push(ForStmt)
	p.expect(ForKeyword)
	p.expect(LeftParen)
	switch p.next {
	case AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword:
		p.parseAssignStmt()
	case ConstKeyword, FriendKeyword, ModuleparKeyword, PrivateKeyword, PublicKeyword, VarKeyword:
		p.parseVarDecl()

	}
	switch p.next {
	case InKeyword:
		p.expect(InKeyword)
		p.parseRef()
	case Semicolon:
		p.expect(Semicolon)
		p.parseExpr()
		p.expect(Semicolon)
		p.parseAssignStmt()

	}
	p.expect(RightParen)
	p.parseBlock()
	p.Pop()
	return true
}

// WhileStmt  = "while" "(" Expr ")" Block.
func (p *parser) parseWhileStmt() bool {
	p.Push(WhileStmt)
	p.expect(WhileKeyword)
	p.expect(LeftParen)
	p.parseExpr()
	p.expect(RightParen)
	p.parseBlock()
	p.Pop()
	return true
}

// DoStmt     = "do" Block "while" "(" Expr ")".
func (p *parser) parseDoStmt() bool {
	p.Push(DoStmt)
	p.expect(DoKeyword)
	p.parseBlock()
	p.expect(WhileKeyword)
	p.expect(LeftParen)
	p.parseExpr()
	p.expect(RightParen)
	p.Pop()
	return true
}

// GotoStmt   = "goto" Ref.
func (p *parser) parseGotoStmt() bool {
	p.Push(GotoStmt)
	p.expect(GotoKeyword)
	p.parseRef()
	p.Pop()
	return true
}

// LabelStmt  = "label" Name.
func (p *parser) parseLabelStmt() bool {
	p.Push(LabelStmt)
	p.expect(LabelKeyword)
	p.parseName()
	p.Pop()
	return true
}

// ReturnStmt = "return" [Expr].
func (p *parser) parseReturnStmt() bool {
	p.Push(ReturnStmt)
	p.expect(ReturnKeyword)
	if p.accept(Add, AddressKeyword, AllKeyword, Any, AnyKeyword, Bitstring, ErrorLiteral, Exclude, FailLiteral, FalseLiteral, Float, Identifier, InconcLiteral, Integer, MapKeyword, MtcKeyword, Mul, NoneLiteral, Not4bKeyword, NotANumber, NotKeyword, NullKeyword, OmitKeyword, PassLiteral, SelfKeyword, String, Sub, SystemKeyword, ThisKeyword, TimerKeyword, TrueLiteral, UniversalKeyword, UnmapKeyword) {
		p.parseExpr()
	}
	p.Pop()
	return true
}

// AltStmt    = ("alt"|"interleave") {modifier} Block.
func (p *parser) parseAltStmt() bool {
	p.Push(AltStmt)
	switch p.next {
	case AltKeyword:
		p.expect(AltKeyword)
	case InterleaveKeyword:
		p.expect(InterleaveKeyword)
	}
	for p.accept(Modifier) {
		p.expect(Modifier)
	}
	p.parseBlock()
	p.Pop()
	return true
}

// AssignStmt = Ref ":=" Expr.
func (p *parser) parseAssignStmt() bool {
	p.Push(AssignStmt)
	p.parseRef()
	p.expect(Assign)
	p.parseExpr()
	p.Pop()
	return true
}

// GuardStmt  = "[" [Expr] "]" Stmt.
func (p *parser) parseGuardStmt() bool {
	p.Push(GuardStmt)
	p.expect(LeftBracket)
	if p.accept(Add, AddressKeyword, AllKeyword, Any, AnyKeyword, Bitstring, ErrorLiteral, Exclude, FailLiteral, FalseLiteral, Float, Identifier, InconcLiteral, Integer, MapKeyword, MtcKeyword, Mul, NoneLiteral, Not4bKeyword, NotANumber, NotKeyword, NullKeyword, OmitKeyword, PassLiteral, SelfKeyword, String, Sub, SystemKeyword, ThisKeyword, TimerKeyword, TrueLiteral, UniversalKeyword, UnmapKeyword) {
		p.parseExpr()
	}
	p.expect(RightBracket)
	p.parseStmt()
	p.Pop()
	return true
}

// Block = BasicBlock ["catch" "(" Ref Name ")" BasicBlock] ["finally" BasicBlock].
func (p *parser) parseBlock() bool {
	p.Push(Block)
	p.parseBasicBlock()
	if p.accept(CatchKeyword) {
		p.expect(CatchKeyword)
		p.expect(LeftParen)
		p.parseRef()

		p.parseName()
		p.expect(RightParen)
		p.parseBasicBlock()
	}
	if p.accept(FinallyKeyword) {
		p.expect(FinallyKeyword)
		p.parseBasicBlock()
	}
	p.Pop()
	return true
}

// BasicBlock = "{" { Stmt ";" } "}".
func (p *parser) parseBasicBlock() bool {
	p.Push(BasicBlock)
	p.expect(LeftBrace)
	for p.accept(Add, AddressKeyword, AllKeyword, AltKeyword, Any, AnyKeyword, Bitstring, ConstKeyword, DoKeyword, ErrorLiteral, Exclude, FailLiteral, FalseLiteral, Float, ForKeyword, FriendKeyword, GotoKeyword, Identifier, IfKeyword, InconcLiteral, Integer, InterleaveKeyword, LabelKeyword, LeftBrace, LeftBracket, MapKeyword, ModuleparKeyword, MtcKeyword, Mul, NoneLiteral, Not4bKeyword, NotANumber, NotKeyword, NullKeyword, OmitKeyword, PassLiteral, PortKeyword, PrivateKeyword, PublicKeyword, ReturnKeyword, SelectKeyword, SelfKeyword, String, Sub, SystemKeyword, TemplateKeyword, ThisKeyword, TimerKeyword, TrueLiteral, UniversalKeyword, UnmapKeyword, VarKeyword, WhileKeyword) {
		p.parseStmt()
		p.expect(Semicolon)
	}
	p.expect(RightBrace)
	p.Pop()
	return true
}

// Exprs = {Expr "," }.
func (p *parser) parseExprs() bool {
	p.Push(Exprs)
	for p.accept(Add, AddressKeyword, AllKeyword, Any, AnyKeyword, Bitstring, ErrorLiteral, Exclude, FailLiteral, FalseLiteral, Float, Identifier, InconcLiteral, Integer, MapKeyword, MtcKeyword, Mul, NoneLiteral, Not4bKeyword, NotANumber, NotKeyword, NullKeyword, OmitKeyword, PassLiteral, SelfKeyword, String, Sub, SystemKeyword, ThisKeyword, TimerKeyword, TrueLiteral, UniversalKeyword, UnmapKeyword) {
		p.parseExpr()
		p.expect(Comma)
	}
	p.Pop()
	return true
}

// PrimaryExpr = Ref { "." Ref | "[" Expr "]" | "(" Exprs ")" }.
func (p *parser) parsePrimaryExpr() bool {
	p.Push(PrimaryExpr)
	p.parseRef()
	for p.accept(Dot, LeftBracket, LeftParen) {
		switch p.next {
		case Dot:
			p.expect(Dot)
			p.parseRef()
		case LeftBracket:
			p.expect(LeftBracket)
			p.parseExpr()
			p.expect(RightBracket)
		case LeftParen:
			p.expect(LeftParen)
			p.parseExprs()
			p.expect(RightParen)
		}
	}
	p.Pop()
	return true
}

// Literal = integer
//         | float
// 	| string
// 	| bitstring
// 	| "true" | "false"
// 	| "none" | "pass" | "inconc" | "fail" | "error"
// 	| "-"
// 	| "?"
// 	| "*"
// 	| "omit"
// 	| "not_a_number"
// 	| "null"
// 	.
func (p *parser) parseLiteral() bool {
	p.Push(Literal)
	switch p.next {
	case Integer:
		p.expect(Integer)
	case Float:
		p.expect(Float)
	case String:
		p.expect(String)
	case Bitstring:
		p.expect(Bitstring)
	case TrueLiteral:
		p.expect(TrueLiteral)
	case FalseLiteral:
		p.expect(FalseLiteral)
	case NoneLiteral:
		p.expect(NoneLiteral)
	case PassLiteral:
		p.expect(PassLiteral)
	case InconcLiteral:
		p.expect(InconcLiteral)
	case FailLiteral:
		p.expect(FailLiteral)
	case ErrorLiteral:
		p.expect(ErrorLiteral)
	case Sub:
		p.expect(Sub)
	case Any:
		p.expect(Any)
	case Mul:
		p.expect(Mul)
	case OmitKeyword:
		p.expect(OmitKeyword)
	case NotANumber:
		p.expect(NotANumber)
	case NullKeyword:
		p.expect(NullKeyword)
	}
	p.Pop()
	return true
}

// TypePars = "<" { TypePar "," } ">" .
func (p *parser) parseTypePars() bool {
	p.Push(TypePars)
	p.expect(Less)
	for p.accept(AddressKeyword, AllKeyword, AnyKeyword, EnumeratedKeyword, Identifier, MapKeyword, MtcKeyword, RecordKeyword, SelfKeyword, SetKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UnionKeyword, UniversalKeyword, UnmapKeyword) {
		p.parseTypePar()
		p.expect(Comma)
	}
	p.expect(Greater)
	p.Pop()
	return true
}

// TypePar = [ Name ":=" ] NestedType .
func (p *parser) parseTypePar() bool {
	p.Push(TypePar)
	if p.accept(Identifier) {
		p.parseName()
		p.expect(Assign)
	}
	p.parseNestedType()
	p.Pop()
	return true
}

// With = "with" "{" {WithStmt ";"} "}".
func (p *parser) parseWith() bool {
	p.Push(With)
	p.expect(WithKeyword)
	p.expect(LeftBrace)
	for p.accept(DisplayKeyword, EncodeKeyword, ExtensionKeyword, OptionalKeyword, VariantKeyword) {
		p.parseWithStmt()
		p.expect(Semicolon)
	}
	p.expect(RightBrace)
	p.Pop()
	return true
}

// WithStmt =  ("encode"|"variant"|"display"|"extension"|"optional") ["override"|"@local"] ["(" WithQualifier [","] ")"] string.
func (p *parser) parseWithStmt() bool {
	p.Push(WithStmt)
	switch p.next {
	case EncodeKeyword:
		p.expect(EncodeKeyword)
	case VariantKeyword:
		p.expect(VariantKeyword)
	case DisplayKeyword:
		p.expect(DisplayKeyword)
	case ExtensionKeyword:
		p.expect(ExtensionKeyword)
	case OptionalKeyword:
		p.expect(OptionalKeyword)
	}
	if p.accept(AtLocal, OverrideKeyword) {
		switch p.next {
		case OverrideKeyword:
			p.expect(OverrideKeyword)
		case AtLocal:
			p.expect(AtLocal)
		}
	}
	if p.accept(LeftParen) {
		p.expect(LeftParen)
		p.parseWithQualifier()
		if p.accept(Comma) {
			p.expect(Comma)
		}
		p.expect(RightParen)
	}
	p.expect(String)
	p.Pop()
	return true
}

// WithQualifier
//     = Ref
//     | "[" Expr "]"
//     | WithKind [ "except" "{" Refs "}" ]
//     .
func (p *parser) parseWithQualifier() bool {
	p.Push(WithQualifier)
	switch p.next {
	case AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword:
		p.parseRef()
	case LeftBracket:
		p.expect(LeftBracket)
		p.parseExpr()
		p.expect(RightBracket)
	case AltstepKeyword, ConstKeyword, FunctionKeyword, GroupKeyword, ModuleparKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword:
		p.parseWithKind()
		if p.accept(ExceptKeyword) {
			p.expect(ExceptKeyword)
			p.expect(LeftBrace)
			p.parseRefs()
			p.expect(RightBrace)
		}
	}
	p.Pop()
	return true
}

// WithKind
//     = "altstep"
//     | "const"
//     | "function"
//     | "group"
//     | "modulepar"
//     | "signature"
//     | "template"
//     | "testcase"
//     | "type"
//     .
func (p *parser) parseWithKind() bool {
	p.Push(WithKind)
	switch p.next {
	case AltstepKeyword:
		p.expect(AltstepKeyword)
	case ConstKeyword:
		p.expect(ConstKeyword)
	case FunctionKeyword:
		p.expect(FunctionKeyword)
	case GroupKeyword:
		p.expect(GroupKeyword)
	case ModuleparKeyword:
		p.expect(ModuleparKeyword)
	case SignatureKeyword:
		p.expect(SignatureKeyword)
	case TemplateKeyword:
		p.expect(TemplateKeyword)
	case TestcaseKeyword:
		p.expect(TestcaseKeyword)
	case TypeKeyword:
		p.expect(TypeKeyword)
	}
	p.Pop()
	return true
}

// Refs = {Ref ","} .
func (p *parser) parseRefs() bool {
	p.Push(Refs)
	for p.accept(AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword) {
		p.parseRef()
		p.expect(Comma)
	}
	p.Pop()
	return true
}

// Extends = "extends" Refs.
func (p *parser) parseExtends() bool {
	p.Push(Extends)
	p.expect(ExtendsKeyword)
	p.parseRefs()
	p.Pop()
	return true
}

// Language = "language" {string ","}.
func (p *parser) parseLanguage() bool {
	p.Push(Language)
	p.expect(LanguageKeyword)
	for p.accept(String) {
		p.expect(String)
		p.expect(Comma)
	}
	p.Pop()
	return true
}

// Return = "return" [NestedTemplate] Ref {ArrayDef} .
func (p *parser) parseReturn() bool {
	p.Push(Return)
	p.expect(ReturnKeyword)
	if p.accept(OmitKeyword, PresentKeyword, TemplateKeyword, ValueKeyword) {
		p.parseNestedTemplate()
	}
	p.parseRef()
	for p.accept(LeftBracket) {
		p.parseArrayDef()
	}
	p.Pop()
	return true
}

// ConfigSpec
//     = "runs" "on" Ref
//     | "system" Ref
//     | "mtc" Ref
//     | "port" Ref
//     | "execute" "on" Ref
//     .
func (p *parser) parseConfigSpec() bool {
	p.Push(ConfigSpec)
	switch p.next {
	case RunsKeyword:
		p.expect(RunsKeyword)
		p.expect(OnKeyword)
		p.parseRef()
	case SystemKeyword:
		p.expect(SystemKeyword)
		p.parseRef()
	case MtcKeyword:
		p.expect(MtcKeyword)
		p.parseRef()
	case PortKeyword:
		p.expect(PortKeyword)
		p.parseRef()
	case ExecuteKeyword:
		p.expect(ExecuteKeyword)
		p.expect(OnKeyword)
		p.parseRef()

	}
	p.Pop()
	return true
}

// Exception = "exception" "(" Refs ")".
func (p *parser) parseException() bool {
	p.Push(Exception)
	p.expect(ExceptionKeyword)
	p.expect(LeftParen)
	p.parseRefs()
	p.expect(RightParen)
	p.Pop()
	return true
}

// Visibility = "private"|"public"|"friend".
func (p *parser) parseVisibility() bool {
	p.Push(Visibility)
	switch p.next {
	case PrivateKeyword:
		p.expect(PrivateKeyword)
	case PublicKeyword:
		p.expect(PublicKeyword)
	case FriendKeyword:
		p.expect(FriendKeyword)
	}
	p.Pop()
	return true
}

// Name = identifier.
func (p *parser) parseName() bool {
	p.Push(Name)
	p.expect(Identifier)
	p.Pop()
	return true
}

// FormalTypePars = "<" FormalTypePar {"," FormalTypePar} [","] ">".
func (p *parser) parseFormalTypePars() bool {
	p.Push(FormalTypePars)
	p.expect(Less)
	p.parseFormalTypePar()
	for p.accept(Comma) {
		p.expect(Comma)
		p.parseFormalTypePar()
	}
	if p.accept(Comma) {
		p.expect(Comma)
	}
	p.expect(Greater)
	p.Pop()
	return true
}

// FormalTypePar = ["in"] ("type"|"signature"|Ref) Declarator.
func (p *parser) parseFormalTypePar() bool {
	p.Push(FormalTypePar)
	if p.accept(InKeyword) {
		p.expect(InKeyword)
	}
	switch p.next {
	case TypeKeyword:
		p.expect(TypeKeyword)
	case SignatureKeyword:
		p.expect(SignatureKeyword)
	case AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword:
		p.parseRef()

	}
	p.parseDeclarator()
	p.Pop()
	return true
}

// FormalPars = "(" FormalPar {"," FormalPar} [","] ")".
func (p *parser) parseFormalPars() bool {
	p.Push(FormalPars)
	p.expect(LeftParen)
	p.parseFormalPar()
	for p.accept(Comma) {
		p.expect(Comma)
		p.parseFormalPar()
	}
	if p.accept(Comma) {
		p.expect(Comma)
	}
	p.expect(RightParen)
	p.Pop()
	return true
}

// FormalPar = ("in"|"out"|"inout") Ref Declarator.
func (p *parser) parseFormalPar() bool {
	p.Push(FormalPar)
	switch p.next {
	case InKeyword:
		p.expect(InKeyword)
	case OutKeyword:
		p.expect(OutKeyword)
	case InoutKeyword:
		p.expect(InoutKeyword)
	}
	p.parseRef()

	p.parseDeclarator()
	p.Pop()
	return true
}

// Declarator = Name {ArrayDef} [":=" Expr].
func (p *parser) parseDeclarator() bool {
	p.Push(Declarator)
	p.parseName()
	for p.accept(LeftBracket) {
		p.parseArrayDef()
	}
	if p.accept(Assign) {
		p.expect(Assign)
		p.parseExpr()
	}
	p.Pop()
	return true
}

// ArrayDef = "[" Expr "]".
func (p *parser) parseArrayDef() bool {
	p.Push(ArrayDef)
	p.expect(LeftBracket)
	p.parseExpr()
	p.expect(RightBracket)
	p.Pop()
	return true
}

// TemplateRestriction = "omit" | "value" | "present".
func (p *parser) parseTemplateRestriction() bool {
	p.Push(TemplateRestriction)
	switch p.next {
	case OmitKeyword:
		p.expect(OmitKeyword)
	case ValueKeyword:
		p.expect(ValueKeyword)
	case PresentKeyword:
		p.expect(PresentKeyword)
	}
	p.Pop()
	return true
}

// NestedTemplate
//     = "template" ["(" TemplateRestriction ")"]
//     | TemplateRestriction
//     .
func (p *parser) parseNestedTemplate() bool {
	p.Push(NestedTemplate)
	switch p.next {
	case TemplateKeyword:
		p.expect(TemplateKeyword)
		if p.accept(LeftParen) {
			p.expect(LeftParen)
			p.parseTemplateRestriction()
			p.expect(RightParen)
		}
	case OmitKeyword, PresentKeyword, ValueKeyword:
		p.parseTemplateRestriction()

	}
	p.Pop()
	return true
}

// NestedStruct = ("record"|"set"|"union") "{" { StructMember "," } "}".
func (p *parser) parseNestedStruct() bool {
	p.Push(NestedStruct)
	switch p.next {
	case RecordKeyword:
		p.expect(RecordKeyword)
	case SetKeyword:
		p.expect(SetKeyword)
	case UnionKeyword:
		p.expect(UnionKeyword)
	}
	p.expect(LeftBrace)
	for p.accept(AddressKeyword, AllKeyword, AnyKeyword, AtDefault, EnumeratedKeyword, Identifier, MapKeyword, MtcKeyword, RecordKeyword, SelfKeyword, SetKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UnionKeyword, UniversalKeyword, UnmapKeyword) {
		p.parseStructMember()
		p.expect(Comma)
	}
	p.expect(RightBrace)
	p.Pop()
	return true
}

// NestedList = ("record"|"set") ["length" "(" Expr ")"] "of" NestedType.
func (p *parser) parseNestedList() bool {
	p.Push(NestedList)
	switch p.next {
	case RecordKeyword:
		p.expect(RecordKeyword)
	case SetKeyword:
		p.expect(SetKeyword)
	}
	if p.accept(LengthKeyword) {
		p.expect(LengthKeyword)
		p.expect(LeftParen)
		p.parseExpr()
		p.expect(RightParen)
	}
	p.expect(OfKeyword)
	p.parseNestedType()
	p.Pop()
	return true
}

// NestedEnum = "enumerated" "{" {EnumLabel "," } "}".
func (p *parser) parseNestedEnum() bool {
	p.Push(NestedEnum)
	p.expect(EnumeratedKeyword)
	p.expect(LeftBrace)
	for p.accept(Identifier) {
		p.parseEnumLabel()
		p.expect(Comma)
	}
	p.expect(RightBrace)
	p.Pop()
	return true
}
