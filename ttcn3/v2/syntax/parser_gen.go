// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at 2022-10-13 11:50:56.97857637 +0200 CEST m=+0.001116945

package syntax

// this is a minimal set of keywords required to parse TTCN-3.
// Note, that the standard specifies more keywords.
var keywords = map[string]Kind{
	"address":       AddressKeyword,
	"all":           AllKeyword,
	"alt":           AltKeyword,
	"altstep":       AltstepKeyword,
	"and4b":         And4bKeyword,
	"and":           AndKeyword,
	"any":           AnyKeyword,
	"case":          CaseKeyword,
	"catch":         CatchKeyword,
	"charstring":    CharstringKeyword,
	"class":         ClassKeyword,
	"component":     ComponentKeyword,
	"configuration": ConfigurationKeyword,
	"connect":       ConnectKeyword,
	"const":         ConstKeyword,
	"control":       ControlKeyword,
	"create":        CreateKeyword,
	"display":       DisplayKeyword,
	"do":            DoKeyword,
	"else":          ElseKeyword,
	"encode":        EncodeKeyword,
	"enumerated":    EnumeratedKeyword,
	"except":        ExceptKeyword,
	"exception":     ExceptionKeyword,
	"execute":       ExecuteKeyword,
	"extends":       ExtendsKeyword,
	"extension":     ExtensionKeyword,
	"external":      ExternalKeyword,
	"finally":       FinallyKeyword,
	"for":           ForKeyword,
	"friend":        FriendKeyword,
	"from":          FromKeyword,
	"function":      FunctionKeyword,
	"goto":          GotoKeyword,
	"group":         GroupKeyword,
	"if":            IfKeyword,
	"import":        ImportKeyword,
	"in":            InKeyword,
	"inout":         InoutKeyword,
	"interleave":    InterleaveKeyword,
	"label":         LabelKeyword,
	"language":      LanguageKeyword,
	"length":        LengthKeyword,
	"map":           MapKeyword,
	"message":       MessageKeyword,
	"mod":           ModKeyword,
	"modifies":      ModifiesKeyword,
	"module":        ModuleKeyword,
	"modulepar":     ModuleparKeyword,
	"mtc":           MtcKeyword,
	"noblock":       NoblockKeyword,
	"not4b":         Not4bKeyword,
	"not":           NotKeyword,
	"null":          NullKeyword,
	"of":            OfKeyword,
	"omit":          OmitKeyword,
	"on":            OnKeyword,
	"optional":      OptionalKeyword,
	"or4b":          Or4bKeyword,
	"or":            OrKeyword,
	"out":           OutKeyword,
	"override":      OverrideKeyword,
	"param":         ParamKeyword,
	"port":          PortKeyword,
	"present":       PresentKeyword,
	"private":       PrivateKeyword,
	"procedure":     ProcedureKeyword,
	"public":        PublicKeyword,
	"realtime":      RealtimeKeyword,
	"record":        RecordKeyword,
	"rem":           RemKeyword,
	"return":        ReturnKeyword,
	"runs":          RunsKeyword,
	"select":        SelectKeyword,
	"self":          SelfKeyword,
	"set":           SetKeyword,
	"signature":     SignatureKeyword,
	"stream":        StreamKeyword,
	"system":        SystemKeyword,
	"template":      TemplateKeyword,
	"testcase":      TestcaseKeyword,
	"this":          ThisKeyword,
	"timer":         TimerKeyword,
	"to":            ToKeyword,
	"type":          TypeKeyword,
	"union":         UnionKeyword,
	"universal":     UniversalKeyword,
	"unmap":         UnmapKeyword,
	"value":         ValueKeyword,
	"var":           VarKeyword,
	"variant":       VariantKeyword,
	"while":         WhileKeyword,
	"with":          WithKeyword,
	"xor4b":         Xor4bKeyword,
	"xor":           XorKeyword,
}

// Module = "module" Name [Language] "{" { Decl ";" } "}" [With] ";".
func (p *parser) parseModule() bool {
	if !p.expect(ModuleKeyword) {
		goto error
	}
	if !p.parseName() {
		goto error
	}
	if p.accept(LanguageKeyword) {
		if !p.parseLanguage() {
			goto error
		}
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(AltstepKeyword, ConfigurationKeyword, ConstKeyword, ControlKeyword, CreateKeyword, ExternalKeyword, FinallyKeyword, FriendKeyword, GroupKeyword, ImportKeyword, ModuleparKeyword, PrivateKeyword, PublicKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword, VarKeyword) {
		if !p.parseDecl() {
			goto error
		}
		if !p.expect(Semicolon) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	if !p.expect(Semicolon) {
		goto error
	}
	return true
error:
	return false
}

// Group = [Visibility] "group" Name "{" { Decl ";" } "}" [With].
func (p *parser) parseGroup() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(GroupKeyword) {
		goto error
	}
	if !p.parseName() {
		goto error
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(AltstepKeyword, ConfigurationKeyword, ConstKeyword, ControlKeyword, CreateKeyword, ExternalKeyword, FinallyKeyword, FriendKeyword, GroupKeyword, ImportKeyword, ModuleparKeyword, PrivateKeyword, PublicKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword, VarKeyword) {
		if !p.parseDecl() {
			goto error
		}
		if !p.expect(Semicolon) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Friend = [Visibility] "friend" "module" Refs [With].
func (p *parser) parseFriend() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(FriendKeyword) {
		goto error
	}
	if !p.expect(ModuleKeyword) {
		goto error
	}
	if !p.parseRefs() {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Import = [Visibility] "import" "from" Ref ["->" Name] ("all" [ExceptSpec] | ImportSpec) [With].
func (p *parser) parseImport() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(ImportKeyword) {
		goto error
	}
	if !p.expect(FromKeyword) {
		goto error
	}
	if !p.parseRef() {
		goto error
	}
	if p.accept(Arrow) {
		if !p.expect(Arrow) {
			goto error
		}
		if !p.parseName() {
			goto error
		}
	}
	switch p.next.Kind() {
	case AllKeyword:
		if !p.expect(AllKeyword) {
			goto error
		}
		if p.accept(ExceptKeyword) {
			if !p.parseExceptSpec() {
				goto error
			}
		}
	case LeftBrace:
		if !p.parseImportSpec() {
			goto error
		}

	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// ExceptSpec = "except" "{" { ExceptStmt ";" } "}".
func (p *parser) parseExceptSpec() bool {
	if !p.expect(ExceptKeyword) {
		goto error
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(AltstepKeyword, ConstKeyword, FunctionKeyword, GroupKeyword, ImportKeyword, ModuleparKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword) {
		if !p.parseExceptStmt() {
			goto error
		}
		if !p.expect(Semicolon) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	return true
error:
	return false
}

// ExceptStmt = ImportKind Refs
//            | "group"    Refs
//            .
func (p *parser) parseExceptStmt() bool {
	switch p.next.Kind() {
	case AltstepKeyword, ConstKeyword, FunctionKeyword, ImportKeyword, ModuleparKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword:
		if !p.parseImportKind() {
			goto error
		}

		if !p.parseRefs() {
			goto error
		}
	case GroupKeyword:
		if !p.expect(GroupKeyword) {
			goto error
		}
		if !p.parseRefs() {
			goto error
		}

	}
	return true
error:
	return false
}

// ImportSpec = "{" { ImportStmt ";" } "}".
func (p *parser) parseImportSpec() bool {
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(AltstepKeyword, ConstKeyword, FunctionKeyword, GroupKeyword, ImportKeyword, ModuleparKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword) {
		if !p.parseImportStmt() {
			goto error
		}
		if !p.expect(Semicolon) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	return true
error:
	return false
}

// ImportKind
//     = "altstep"
//     | "const"
//     | "function"
//     | "import"
//     | "modulepar"
//     | "signature"
//     | "template"
//     | "testcase"
//     | "type"
//     .
func (p *parser) parseImportKind() bool {
	switch p.next.Kind() {
	case AltstepKeyword:
		if !p.expect(AltstepKeyword) {
			goto error
		}
	case ConstKeyword:
		if !p.expect(ConstKeyword) {
			goto error
		}
	case FunctionKeyword:
		if !p.expect(FunctionKeyword) {
			goto error
		}
	case ImportKeyword:
		if !p.expect(ImportKeyword) {
			goto error
		}
	case ModuleparKeyword:
		if !p.expect(ModuleparKeyword) {
			goto error
		}
	case SignatureKeyword:
		if !p.expect(SignatureKeyword) {
			goto error
		}
	case TemplateKeyword:
		if !p.expect(TemplateKeyword) {
			goto error
		}
	case TestcaseKeyword:
		if !p.expect(TestcaseKeyword) {
			goto error
		}
	case TypeKeyword:
		if !p.expect(TypeKeyword) {
			goto error
		}
	}
	return true
error:
	return false
}

// Signature = [Visibility] "signature" Name [FormalTypePars] FormalPars [Return] ["noblock"] [Exception] [With].
func (p *parser) parseSignature() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(SignatureKeyword) {
		goto error
	}
	if !p.parseName() {
		goto error
	}
	if p.accept(Less) {
		if !p.parseFormalTypePars() {
			goto error
		}
	}
	if !p.parseFormalPars() {
		goto error
	}
	if p.accept(ReturnKeyword) {
		if !p.parseReturn() {
			goto error
		}
	}
	if p.accept(NoblockKeyword) {
		if !p.expect(NoblockKeyword) {
			goto error
		}
	}
	if p.accept(ExceptionKeyword) {
		if !p.parseException() {
			goto error
		}
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Component = [Visibility] "type" "component" Name [FormalTypePars][Extends] Block [With].
func (p *parser) parseComponent() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if !p.expect(ComponentKeyword) {
		goto error
	}
	if !p.parseName() {
		goto error
	}
	if p.accept(Less) {
		if !p.parseFormalTypePars() {
			goto error
		}
	}
	if p.accept(ExtendsKeyword) {
		if !p.parseExtends() {
			goto error
		}
	}
	if !p.parseBlock() {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Port = [Visibility] "type" "port" Name PortKind {PortSpec} "{" {PortAttribute ";"} "}" [With].
func (p *parser) parsePort() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if !p.expect(PortKeyword) {
		goto error
	}
	if !p.parseName() {
		goto error
	}

	if !p.parsePortKind() {
		goto error
	}
	for p.accept(ConnectKeyword, MapKeyword, RealtimeKeyword) {
		if !p.parsePortSpec() {
			goto error
		}
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(AddressKeyword, InKeyword, InoutKeyword, MapKeyword, OutKeyword, UnmapKeyword) {
		if !p.parsePortAttribute() {
			goto error
		}
		if !p.expect(Semicolon) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// PortKind = "message"
//          | "procedure"
// 	 | "stream"
// 	 .
func (p *parser) parsePortKind() bool {
	switch p.next.Kind() {
	case MessageKeyword:
		if !p.expect(MessageKeyword) {
			goto error
		}
	case ProcedureKeyword:
		if !p.expect(ProcedureKeyword) {
			goto error
		}
	case StreamKeyword:
		if !p.expect(StreamKeyword) {
			goto error
		}
	}
	return true
error:
	return false
}

// PortSpec = "realtime"
//          | "map" "to" Refs
// 	 | "connect" "to" Refs
// 	 .
func (p *parser) parsePortSpec() bool {
	switch p.next.Kind() {
	case RealtimeKeyword:
		if !p.expect(RealtimeKeyword) {
			goto error
		}
	case MapKeyword:
		if !p.expect(MapKeyword) {
			goto error
		}
		if !p.expect(ToKeyword) {
			goto error
		}
		if !p.parseRefs() {
			goto error
		}
	case ConnectKeyword:
		if !p.expect(ConnectKeyword) {
			goto error
		}
		if !p.expect(ToKeyword) {
			goto error
		}
		if !p.parseRefs() {
			goto error
		}

	}
	return true
error:
	return false
}

// PortAttribute = "map"   "param" FormalPars
//               | "unmap" "param" FormalPars
//               | "address" Ref [PortTranslation]
//               | ("in"|"out"|"inout") {PortElement ","}
//               .
func (p *parser) parsePortAttribute() bool {
	switch p.next.Kind() {
	case MapKeyword:
		if !p.expect(MapKeyword) {
			goto error
		}
		if !p.expect(ParamKeyword) {
			goto error
		}
		if !p.parseFormalPars() {
			goto error
		}
	case UnmapKeyword:
		if !p.expect(UnmapKeyword) {
			goto error
		}
		if !p.expect(ParamKeyword) {
			goto error
		}
		if !p.parseFormalPars() {
			goto error
		}
	case AddressKeyword:
		if !p.expect(AddressKeyword) {
			goto error
		}
		if !p.parseRef() {
			goto error
		}
		if p.accept(FromKeyword, ToKeyword) {
			if !p.parsePortTranslation() {
				goto error
			}
		}
	case InKeyword, InoutKeyword, OutKeyword:
		switch p.next.Kind() {
		case InKeyword:
			if !p.expect(InKeyword) {
				goto error
			}
		case OutKeyword:
			if !p.expect(OutKeyword) {
				goto error
			}
		case InoutKeyword:
			if !p.expect(InoutKeyword) {
				goto error
			}
		}
		for p.accept(AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword) {
			if !p.parsePortElement() {
				goto error
			}
			if !p.expect(Comma) {
				goto error
			}
		}
	}
	return true
error:
	return false
}

// PortElement = Ref [PortTranslation].
func (p *parser) parsePortElement() bool {
	if !p.parseRef() {
		goto error
	}
	if p.accept(FromKeyword, ToKeyword) {
		if !p.parsePortTranslation() {
			goto error
		}
	}
	return true
error:
	return false
}

// PortTranslation =("from"|"to") Ref "with" Ref "(" ")".
func (p *parser) parsePortTranslation() bool {
	switch p.next.Kind() {
	case FromKeyword:
		if !p.expect(FromKeyword) {
			goto error
		}
	case ToKeyword:
		if !p.expect(ToKeyword) {
			goto error
		}
	}
	if !p.parseRef() {
		goto error
	}
	if !p.expect(WithKeyword) {
		goto error
	}
	if !p.parseRef() {
		goto error
	}
	if !p.expect(LeftParen) {
		goto error
	}
	if !p.expect(RightParen) {
		goto error
	}
	return true
error:
	return false
}

// SubType = [Visibility] "type" Ref Name [FormalTypePars] {ArrayDef} ["(" Exprs ")"] [With].
func (p *parser) parseSubType() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if !p.parseRef() {
		goto error
	}

	if !p.parseName() {
		goto error
	}
	if p.accept(Less) {
		if !p.parseFormalTypePars() {
			goto error
		}
	}
	for p.accept(LeftBracket) {
		if !p.parseArrayDef() {
			goto error
		}
	}
	if p.accept(LeftParen) {
		if !p.expect(LeftParen) {
			goto error
		}
		if !p.parseExprs() {
			goto error
		}
		if !p.expect(RightParen) {
			goto error
		}
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Struct = [Visibility] "type" StructKind Name [FormalTypePars] "{" { StructMember "," } "}" [With].
func (p *parser) parseStruct() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if !p.parseStructKind() {
		goto error
	}

	if !p.parseName() {
		goto error
	}
	if p.accept(Less) {
		if !p.parseFormalTypePars() {
			goto error
		}
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(AddressKeyword, AllKeyword, AnyKeyword, AtDefault, EnumeratedKeyword, Identifier, MapKeyword, MtcKeyword, RecordKeyword, SelfKeyword, SetKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UnionKeyword, UniversalKeyword, UnmapKeyword) {
		if !p.parseStructMember() {
			goto error
		}
		if !p.expect(Comma) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// StructKind = "record" | "set" | "union".
func (p *parser) parseStructKind() bool {
	switch p.next.Kind() {
	case RecordKeyword:
		if !p.expect(RecordKeyword) {
			goto error
		}
	case SetKeyword:
		if !p.expect(SetKeyword) {
			goto error
		}
	case UnionKeyword:
		if !p.expect(UnionKeyword) {
			goto error
		}
	}
	return true
error:
	return false
}

// StructMember = ["@default"] NestedType Name {ArrayDef} ["(" Exprs ")"].
func (p *parser) parseStructMember() bool {
	if p.accept(AtDefault) {
		if !p.expect(AtDefault) {
			goto error
		}
	}
	if !p.parseNestedType() {
		goto error
	}

	if !p.parseName() {
		goto error
	}
	for p.accept(LeftBracket) {
		if !p.parseArrayDef() {
			goto error
		}
	}
	if p.accept(LeftParen) {
		if !p.expect(LeftParen) {
			goto error
		}
		if !p.parseExprs() {
			goto error
		}
		if !p.expect(RightParen) {
			goto error
		}
	}
	return true
error:
	return false
}

// List = [Visibility] "type" ListKind ["length" "(" Expr ")"] "of" NestedType Name [With].
func (p *parser) parseList() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if !p.parseListKind() {
		goto error
	}
	if p.accept(LengthKeyword) {
		if !p.expect(LengthKeyword) {
			goto error
		}
		if !p.expect(LeftParen) {
			goto error
		}
		if !p.parseExpr() {
			goto error
		}
		if !p.expect(RightParen) {
			goto error
		}
	}
	if !p.expect(OfKeyword) {
		goto error
	}
	if !p.parseNestedType() {
		goto error
	}

	if !p.parseName() {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// ListKind = "record" | "set".
func (p *parser) parseListKind() bool {
	switch p.next.Kind() {
	case RecordKeyword:
		if !p.expect(RecordKeyword) {
			goto error
		}
	case SetKeyword:
		if !p.expect(SetKeyword) {
			goto error
		}
	}
	return true
error:
	return false
}

// Enum = [Visibility] "type" "enumerated" Name "{" { EnumLabel "," } "}" [With].
func (p *parser) parseEnum() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if !p.expect(EnumeratedKeyword) {
		goto error
	}
	if !p.parseName() {
		goto error
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(Identifier) {
		if !p.parseEnumLabel() {
			goto error
		}
		if !p.expect(Comma) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// EnumLabel = Name ["(" Exprs ")"].
func (p *parser) parseEnumLabel() bool {
	if !p.parseName() {
		goto error
	}
	if p.accept(LeftParen) {
		if !p.expect(LeftParen) {
			goto error
		}
		if !p.parseExprs() {
			goto error
		}
		if !p.expect(RightParen) {
			goto error
		}
	}
	return true
error:
	return false
}

// Map = [Visibility] "type" "map" "from" Ref "to" Ref Name [With].
func (p *parser) parseMap() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if !p.expect(MapKeyword) {
		goto error
	}
	if !p.expect(FromKeyword) {
		goto error
	}
	if !p.parseRef() {
		goto error
	}
	if !p.expect(ToKeyword) {
		goto error
	}
	if !p.parseRef() {
		goto error
	}

	if !p.parseName() {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Class = [Visibility] "type" ["external"] "class" {modifier} Name [Extends] {ConfigSpec} "{" { Decl ";" } "}" ["finally" Block] [With].
func (p *parser) parseClass() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if p.accept(ExternalKeyword) {
		if !p.expect(ExternalKeyword) {
			goto error
		}
	}
	if !p.expect(ClassKeyword) {
		goto error
	}
	for p.accept(Modifier) {
		if !p.expect(Modifier) {
			goto error
		}
	}
	if !p.parseName() {
		goto error
	}
	if p.accept(ExtendsKeyword) {
		if !p.parseExtends() {
			goto error
		}
	}
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		if !p.parseConfigSpec() {
			goto error
		}
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(AltstepKeyword, ConfigurationKeyword, ConstKeyword, ControlKeyword, CreateKeyword, ExternalKeyword, FinallyKeyword, FriendKeyword, GroupKeyword, ImportKeyword, ModuleparKeyword, PrivateKeyword, PublicKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword, VarKeyword) {
		if !p.parseDecl() {
			goto error
		}
		if !p.expect(Semicolon) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	if p.accept(FinallyKeyword) {
		if !p.expect(FinallyKeyword) {
			goto error
		}
		if !p.parseBlock() {
			goto error
		}
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Constructor = [Visibility] "create" FormalPars ["external" FormalPars] [":" Ref "(" Exprs ")" ] [Block] .
func (p *parser) parseConstructor() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(CreateKeyword) {
		goto error
	}
	if !p.parseFormalPars() {
		goto error
	}
	if p.accept(ExternalKeyword) {
		if !p.expect(ExternalKeyword) {
			goto error
		}
		if !p.parseFormalPars() {
			goto error
		}
	}
	if p.accept(Colon) {
		if !p.expect(Colon) {
			goto error
		}
		if !p.parseRef() {
			goto error
		}
		if !p.expect(LeftParen) {
			goto error
		}
		if !p.parseExprs() {
			goto error
		}
		if !p.expect(RightParen) {
			goto error
		}
	}
	if p.accept(LeftBrace) {
		if !p.parseBlock() {
			goto error
		}
	}
	return true
error:
	return false
}

// Control = "control" Block.
func (p *parser) parseControl() bool {
	if !p.expect(ControlKeyword) {
		goto error
	}
	if !p.parseBlock() {
		goto error
	}
	return true
error:
	return false
}

// Destructor = "finally" Block.
func (p *parser) parseDestructor() bool {
	if !p.expect(FinallyKeyword) {
		goto error
	}
	if !p.parseBlock() {
		goto error
	}
	return true
error:
	return false
}

// TestcaseType = [Visibility] "type" "testcase" Name FormalPars {ConfigSpec} [With].
func (p *parser) parseTestcaseType() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if !p.expect(TestcaseKeyword) {
		goto error
	}
	if !p.parseName() {
		goto error
	}

	if !p.parseFormalPars() {
		goto error
	}
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		if !p.parseConfigSpec() {
			goto error
		}
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// FunctionType = [Visibility] "type" "function" {modifier} Name FormalPars {ConfigSpec} [Return] [With].
func (p *parser) parseFunctionType() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if !p.expect(FunctionKeyword) {
		goto error
	}
	for p.accept(Modifier) {
		if !p.expect(Modifier) {
			goto error
		}
	}
	if !p.parseName() {
		goto error
	}

	if !p.parseFormalPars() {
		goto error
	}
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		if !p.parseConfigSpec() {
			goto error
		}
	}
	if p.accept(ReturnKeyword) {
		if !p.parseReturn() {
			goto error
		}
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// AltstepType = [Visibility] "type" "altstep" {modifier} ["interleave"] Name FormalPars {ConfigSpec} [With].
func (p *parser) parseAltstepType() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TypeKeyword) {
		goto error
	}
	if !p.expect(AltstepKeyword) {
		goto error
	}
	for p.accept(Modifier) {
		if !p.expect(Modifier) {
			goto error
		}
	}
	if p.accept(InterleaveKeyword) {
		if !p.expect(InterleaveKeyword) {
			goto error
		}
	}
	if !p.parseName() {
		goto error
	}

	if !p.parseFormalPars() {
		goto error
	}
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		if !p.parseConfigSpec() {
			goto error
		}
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// VarDecl = [Visibility] ("const"|"var"|"modulepar") [NestedTemplate] {modifier} Ref Declarator { "," Declarator} [With].
func (p *parser) parseVarDecl() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	switch p.next.Kind() {
	case ConstKeyword:
		if !p.expect(ConstKeyword) {
			goto error
		}
	case VarKeyword:
		if !p.expect(VarKeyword) {
			goto error
		}
	case ModuleparKeyword:
		if !p.expect(ModuleparKeyword) {
			goto error
		}
	}
	if p.accept(OmitKeyword, PresentKeyword, TemplateKeyword, ValueKeyword) {
		if !p.parseNestedTemplate() {
			goto error
		}
	}
	for p.accept(Modifier) {
		if !p.expect(Modifier) {
			goto error
		}
	}
	if !p.parseRef() {
		goto error
	}

	if !p.parseDeclarator() {
		goto error
	}
	for p.accept(Comma) {
		if !p.expect(Comma) {
			goto error
		}
		if !p.parseDeclarator() {
			goto error
		}
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// TimerDecl = "timer" Declarator { "," Declarator} [With].
func (p *parser) parseTimerDecl() bool {
	if !p.expect(TimerKeyword) {
		goto error
	}
	if !p.parseDeclarator() {
		goto error
	}
	for p.accept(Comma) {
		if !p.expect(Comma) {
			goto error
		}
		if !p.parseDeclarator() {
			goto error
		}
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// PortDecl = "port" Ref Declarator { "," Declarator} [With].
func (p *parser) parsePortDecl() bool {
	if !p.expect(PortKeyword) {
		goto error
	}
	if !p.parseRef() {
		goto error
	}

	if !p.parseDeclarator() {
		goto error
	}
	for p.accept(Comma) {
		if !p.expect(Comma) {
			goto error
		}
		if !p.parseDeclarator() {
			goto error
		}
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Template = [Visibility] "template" [ "(" TemplateRestriction ")"] {modifier} Ref Name [FormalPars] ["modifies" Ref] ":=" Expr [With].
func (p *parser) parseTemplate() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TemplateKeyword) {
		goto error
	}
	if p.accept(LeftParen) {
		if !p.expect(LeftParen) {
			goto error
		}
		if !p.parseTemplateRestriction() {
			goto error
		}
		if !p.expect(RightParen) {
			goto error
		}
	}
	for p.accept(Modifier) {
		if !p.expect(Modifier) {
			goto error
		}
	}
	if !p.parseRef() {
		goto error
	}

	if !p.parseName() {
		goto error
	}
	if p.accept(LeftParen) {
		if !p.parseFormalPars() {
			goto error
		}
	}
	if p.accept(ModifiesKeyword) {
		if !p.expect(ModifiesKeyword) {
			goto error
		}
		if !p.parseRef() {
			goto error
		}
	}
	if !p.expect(Assign) {
		goto error
	}
	if !p.parseExpr() {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Testcase = [Visibility] "testcase" Name FormalPars {ConfigSpec} Block.
func (p *parser) parseTestcase() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(TestcaseKeyword) {
		goto error
	}
	if !p.parseName() {
		goto error
	}

	if !p.parseFormalPars() {
		goto error
	}
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		if !p.parseConfigSpec() {
			goto error
		}
	}
	if !p.parseBlock() {
		goto error
	}
	return true
error:
	return false
}

// Function = [Visibility] ["external"] "function" {modifier} Name FormalPars {ConfigSpec} [Return] [Exception] [Block] [With].
func (p *parser) parseFunction() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if p.accept(ExternalKeyword) {
		if !p.expect(ExternalKeyword) {
			goto error
		}
	}
	if !p.expect(FunctionKeyword) {
		goto error
	}
	for p.accept(Modifier) {
		if !p.expect(Modifier) {
			goto error
		}
	}
	if !p.parseName() {
		goto error
	}

	if !p.parseFormalPars() {
		goto error
	}
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		if !p.parseConfigSpec() {
			goto error
		}
	}
	if p.accept(ReturnKeyword) {
		if !p.parseReturn() {
			goto error
		}
	}
	if p.accept(ExceptionKeyword) {
		if !p.parseException() {
			goto error
		}
	}
	if p.accept(LeftBrace) {
		if !p.parseBlock() {
			goto error
		}
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Configuration = [Visibility] "configuration" Name FormalPars {ConfigSpec} Block [With].
func (p *parser) parseConfiguration() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(ConfigurationKeyword) {
		goto error
	}
	if !p.parseName() {
		goto error
	}

	if !p.parseFormalPars() {
		goto error
	}
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		if !p.parseConfigSpec() {
			goto error
		}
	}
	if !p.parseBlock() {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// Altstep = [Visibility] "altstep" {modifier} ["interleave"] Name FormalPars {ConfigSpec} Block [With].
func (p *parser) parseAltstep() bool {
	if p.accept(FriendKeyword, PrivateKeyword, PublicKeyword) {
		if !p.parseVisibility() {
			goto error
		}
	}
	if !p.expect(AltstepKeyword) {
		goto error
	}
	for p.accept(Modifier) {
		if !p.expect(Modifier) {
			goto error
		}
	}
	if p.accept(InterleaveKeyword) {
		if !p.expect(InterleaveKeyword) {
			goto error
		}
	}
	if !p.parseName() {
		goto error
	}

	if !p.parseFormalPars() {
		goto error
	}
	for p.accept(ExecuteKeyword, MtcKeyword, PortKeyword, RunsKeyword, SystemKeyword) {
		if !p.parseConfigSpec() {
			goto error
		}
	}
	if !p.parseBlock() {
		goto error
	}
	if p.accept(WithKeyword) {
		if !p.parseWith() {
			goto error
		}
	}
	return true
error:
	return false
}

// IfStmt     = "if" "(" [(AssignStmt|VarDecl) ";"] Expr ")" Block {"else" "if" "(" Expr ")" Block} ["else" Block].
func (p *parser) parseIfStmt() bool {
	if !p.expect(IfKeyword) {
		goto error
	}
	if !p.expect(LeftParen) {
		goto error
	}
	if p.accept(AddressKeyword, AllKeyword, AnyKeyword, ConstKeyword, FriendKeyword, Identifier, MapKeyword, ModuleparKeyword, MtcKeyword, PrivateKeyword, PublicKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword, VarKeyword) {
		switch p.next.Kind() {
		case AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword:
			if !p.parseAssignStmt() {
				goto error
			}
		case ConstKeyword, FriendKeyword, ModuleparKeyword, PrivateKeyword, PublicKeyword, VarKeyword:
			if !p.parseVarDecl() {
				goto error
			}

		}
		if !p.expect(Semicolon) {
			goto error
		}
	}
	if !p.parseExpr() {
		goto error
	}
	if !p.expect(RightParen) {
		goto error
	}
	if !p.parseBlock() {
		goto error
	}
	for p.accept(ElseKeyword) {
		if !p.expect(ElseKeyword) {
			goto error
		}
		if !p.expect(IfKeyword) {
			goto error
		}
		if !p.expect(LeftParen) {
			goto error
		}
		if !p.parseExpr() {
			goto error
		}
		if !p.expect(RightParen) {
			goto error
		}
		if !p.parseBlock() {
			goto error
		}
	}
	if p.accept(ElseKeyword) {
		if !p.expect(ElseKeyword) {
			goto error
		}
		if !p.parseBlock() {
			goto error
		}
	}
	return true
error:
	return false
}

// SelectStmt = "select" ["union"|"class"] "(" Expr ")" "{" { "case" ("else"|"(" Expr ")") Block } "}".
func (p *parser) parseSelectStmt() bool {
	if !p.expect(SelectKeyword) {
		goto error
	}
	if p.accept(ClassKeyword, UnionKeyword) {
		switch p.next.Kind() {
		case UnionKeyword:
			if !p.expect(UnionKeyword) {
				goto error
			}
		case ClassKeyword:
			if !p.expect(ClassKeyword) {
				goto error
			}
		}
	}
	if !p.expect(LeftParen) {
		goto error
	}
	if !p.parseExpr() {
		goto error
	}
	if !p.expect(RightParen) {
		goto error
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(CaseKeyword) {
		if !p.expect(CaseKeyword) {
			goto error
		}
		switch p.next.Kind() {
		case ElseKeyword:
			if !p.expect(ElseKeyword) {
				goto error
			}
		case LeftParen:
			if !p.expect(LeftParen) {
				goto error
			}
			if !p.parseExpr() {
				goto error
			}
			if !p.expect(RightParen) {
				goto error
			}
		}
		if !p.parseBlock() {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	return true
error:
	return false
}

// ForStmt    = "for" "(" (AssignStmt|VarDecl) ("in" Ref|";" Expr";" AssignStmt) ")" Block.
func (p *parser) parseForStmt() bool {
	if !p.expect(ForKeyword) {
		goto error
	}
	if !p.expect(LeftParen) {
		goto error
	}
	switch p.next.Kind() {
	case AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword:
		if !p.parseAssignStmt() {
			goto error
		}
	case ConstKeyword, FriendKeyword, ModuleparKeyword, PrivateKeyword, PublicKeyword, VarKeyword:
		if !p.parseVarDecl() {
			goto error
		}

	}
	switch p.next.Kind() {
	case InKeyword:
		if !p.expect(InKeyword) {
			goto error
		}
		if !p.parseRef() {
			goto error
		}
	case Semicolon:
		if !p.expect(Semicolon) {
			goto error
		}
		if !p.parseExpr() {
			goto error
		}
		if !p.expect(Semicolon) {
			goto error
		}
		if !p.parseAssignStmt() {
			goto error
		}

	}
	if !p.expect(RightParen) {
		goto error
	}
	if !p.parseBlock() {
		goto error
	}
	return true
error:
	return false
}

// WhileStmt  = "while" "(" Expr ")" Block.
func (p *parser) parseWhileStmt() bool {
	if !p.expect(WhileKeyword) {
		goto error
	}
	if !p.expect(LeftParen) {
		goto error
	}
	if !p.parseExpr() {
		goto error
	}
	if !p.expect(RightParen) {
		goto error
	}
	if !p.parseBlock() {
		goto error
	}
	return true
error:
	return false
}

// DoStmt     = "do" Block "while" "(" Expr ")".
func (p *parser) parseDoStmt() bool {
	if !p.expect(DoKeyword) {
		goto error
	}
	if !p.parseBlock() {
		goto error
	}
	if !p.expect(WhileKeyword) {
		goto error
	}
	if !p.expect(LeftParen) {
		goto error
	}
	if !p.parseExpr() {
		goto error
	}
	if !p.expect(RightParen) {
		goto error
	}
	return true
error:
	return false
}

// GotoStmt   = "goto" Ref.
func (p *parser) parseGotoStmt() bool {
	if !p.expect(GotoKeyword) {
		goto error
	}
	if !p.parseRef() {
		goto error
	}
	return true
error:
	return false
}

// LabelStmt  = "label" Name.
func (p *parser) parseLabelStmt() bool {
	if !p.expect(LabelKeyword) {
		goto error
	}
	if !p.parseName() {
		goto error
	}
	return true
error:
	return false
}

// ReturnStmt = "return" [Expr].
func (p *parser) parseReturnStmt() bool {
	if !p.expect(ReturnKeyword) {
		goto error
	}
	if p.accept(Add, AddressKeyword, AllKeyword, Any, AnyKeyword, Bitstring, ErrorLiteral, Exclude, FailLiteral, FalseLiteral, Float, Identifier, InconcLiteral, Integer, MapKeyword, MtcKeyword, Mul, NoneLiteral, Not4bKeyword, NotANumber, NotKeyword, NullKeyword, OmitKeyword, PassLiteral, SelfKeyword, String, Sub, SystemKeyword, ThisKeyword, TimerKeyword, TrueLiteral, UniversalKeyword, UnmapKeyword) {
		if !p.parseExpr() {
			goto error
		}
	}
	return true
error:
	return false
}

// AltStmt    = ("alt"|"interleave") {modifier} Block.
func (p *parser) parseAltStmt() bool {
	switch p.next.Kind() {
	case AltKeyword:
		if !p.expect(AltKeyword) {
			goto error
		}
	case InterleaveKeyword:
		if !p.expect(InterleaveKeyword) {
			goto error
		}
	}
	for p.accept(Modifier) {
		if !p.expect(Modifier) {
			goto error
		}
	}
	if !p.parseBlock() {
		goto error
	}
	return true
error:
	return false
}

// AssignStmt = Ref ":=" Expr.
func (p *parser) parseAssignStmt() bool {
	if !p.parseRef() {
		goto error
	}
	if !p.expect(Assign) {
		goto error
	}
	if !p.parseExpr() {
		goto error
	}
	return true
error:
	return false
}

// GuardStmt  = "[" [Expr] "]" Stmt.
func (p *parser) parseGuardStmt() bool {
	if !p.expect(LeftBracket) {
		goto error
	}
	if p.accept(Add, AddressKeyword, AllKeyword, Any, AnyKeyword, Bitstring, ErrorLiteral, Exclude, FailLiteral, FalseLiteral, Float, Identifier, InconcLiteral, Integer, MapKeyword, MtcKeyword, Mul, NoneLiteral, Not4bKeyword, NotANumber, NotKeyword, NullKeyword, OmitKeyword, PassLiteral, SelfKeyword, String, Sub, SystemKeyword, ThisKeyword, TimerKeyword, TrueLiteral, UniversalKeyword, UnmapKeyword) {
		if !p.parseExpr() {
			goto error
		}
	}
	if !p.expect(RightBracket) {
		goto error
	}
	if !p.parseStmt() {
		goto error
	}
	return true
error:
	return false
}

// Block = BasicBlock ["catch" "(" Ref Name ")" BasicBlock] ["finally" BasicBlock].
func (p *parser) parseBlock() bool {
	if !p.parseBasicBlock() {
		goto error
	}
	if p.accept(CatchKeyword) {
		if !p.expect(CatchKeyword) {
			goto error
		}
		if !p.expect(LeftParen) {
			goto error
		}
		if !p.parseRef() {
			goto error
		}

		if !p.parseName() {
			goto error
		}
		if !p.expect(RightParen) {
			goto error
		}
		if !p.parseBasicBlock() {
			goto error
		}
	}
	if p.accept(FinallyKeyword) {
		if !p.expect(FinallyKeyword) {
			goto error
		}
		if !p.parseBasicBlock() {
			goto error
		}
	}
	return true
error:
	return false
}

// BasicBlock = "{" { Stmt ";" } "}".
func (p *parser) parseBasicBlock() bool {
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(Add, AddressKeyword, AllKeyword, AltKeyword, Any, AnyKeyword, Bitstring, ConstKeyword, DoKeyword, ErrorLiteral, Exclude, FailLiteral, FalseLiteral, Float, ForKeyword, FriendKeyword, GotoKeyword, Identifier, IfKeyword, InconcLiteral, Integer, InterleaveKeyword, LabelKeyword, LeftBrace, LeftBracket, MapKeyword, ModuleparKeyword, MtcKeyword, Mul, NoneLiteral, Not4bKeyword, NotANumber, NotKeyword, NullKeyword, OmitKeyword, PassLiteral, PortKeyword, PrivateKeyword, PublicKeyword, ReturnKeyword, SelectKeyword, SelfKeyword, String, Sub, SystemKeyword, TemplateKeyword, ThisKeyword, TimerKeyword, TrueLiteral, UniversalKeyword, UnmapKeyword, VarKeyword, WhileKeyword) {
		if !p.parseStmt() {
			goto error
		}
		if !p.expect(Semicolon) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	return true
error:
	return false
}

// Exprs = {Expr "," }.
func (p *parser) parseExprs() bool {
	for p.accept(Add, AddressKeyword, AllKeyword, Any, AnyKeyword, Bitstring, ErrorLiteral, Exclude, FailLiteral, FalseLiteral, Float, Identifier, InconcLiteral, Integer, MapKeyword, MtcKeyword, Mul, NoneLiteral, Not4bKeyword, NotANumber, NotKeyword, NullKeyword, OmitKeyword, PassLiteral, SelfKeyword, String, Sub, SystemKeyword, ThisKeyword, TimerKeyword, TrueLiteral, UniversalKeyword, UnmapKeyword) {
		if !p.parseExpr() {
			goto error
		}
		if !p.expect(Comma) {
			goto error
		}
	}
	return true
error:
	return false
}

// PrimaryExpr = Ref { "." Ref | "[" Expr "]" | "(" Exprs ")" }.
func (p *parser) parsePrimaryExpr() bool {
	if !p.parseRef() {
		goto error
	}
	for p.accept(Dot, LeftBracket, LeftParen) {
		switch p.next.Kind() {
		case Dot:
			if !p.expect(Dot) {
				goto error
			}
			if !p.parseRef() {
				goto error
			}
		case LeftBracket:
			if !p.expect(LeftBracket) {
				goto error
			}
			if !p.parseExpr() {
				goto error
			}
			if !p.expect(RightBracket) {
				goto error
			}
		case LeftParen:
			if !p.expect(LeftParen) {
				goto error
			}
			if !p.parseExprs() {
				goto error
			}
			if !p.expect(RightParen) {
				goto error
			}
		}
	}
	return true
error:
	return false
}

// Literal = integer
//         | float
// 	| string
// 	| bitstring
// 	| "true" | "false"
// 	| "none" | "pass" | "inconc" | "fail" | "error"
// 	| "-"
// 	| "?"
// 	| "*"
// 	| "omit"
// 	| "not_a_number"
// 	| "null"
// 	.
func (p *parser) parseLiteral() bool {
	switch p.next.Kind() {
	case Integer:
		if !p.expect(Integer) {
			goto error
		}
	case Float:
		if !p.expect(Float) {
			goto error
		}
	case String:
		if !p.expect(String) {
			goto error
		}
	case Bitstring:
		if !p.expect(Bitstring) {
			goto error
		}
	case TrueLiteral:
		if !p.expect(TrueLiteral) {
			goto error
		}
	case FalseLiteral:
		if !p.expect(FalseLiteral) {
			goto error
		}
	case NoneLiteral:
		if !p.expect(NoneLiteral) {
			goto error
		}
	case PassLiteral:
		if !p.expect(PassLiteral) {
			goto error
		}
	case InconcLiteral:
		if !p.expect(InconcLiteral) {
			goto error
		}
	case FailLiteral:
		if !p.expect(FailLiteral) {
			goto error
		}
	case ErrorLiteral:
		if !p.expect(ErrorLiteral) {
			goto error
		}
	case Sub:
		if !p.expect(Sub) {
			goto error
		}
	case Any:
		if !p.expect(Any) {
			goto error
		}
	case Mul:
		if !p.expect(Mul) {
			goto error
		}
	case OmitKeyword:
		if !p.expect(OmitKeyword) {
			goto error
		}
	case NotANumber:
		if !p.expect(NotANumber) {
			goto error
		}
	case NullKeyword:
		if !p.expect(NullKeyword) {
			goto error
		}
	}
	return true
error:
	return false
}

// TypePars = "<" { TypePar "," } ">" .
func (p *parser) parseTypePars() bool {
	if !p.expect(Less) {
		goto error
	}
	for p.accept(AddressKeyword, AllKeyword, AnyKeyword, EnumeratedKeyword, Identifier, MapKeyword, MtcKeyword, RecordKeyword, SelfKeyword, SetKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UnionKeyword, UniversalKeyword, UnmapKeyword) {
		if !p.parseTypePar() {
			goto error
		}
		if !p.expect(Comma) {
			goto error
		}
	}
	if !p.expect(Greater) {
		goto error
	}
	return true
error:
	return false
}

// TypePar = [ Name ":=" ] NestedType .
func (p *parser) parseTypePar() bool {
	if p.accept(Identifier) {
		if !p.parseName() {
			goto error
		}
		if !p.expect(Assign) {
			goto error
		}
	}
	if !p.parseNestedType() {
		goto error
	}
	return true
error:
	return false
}

// With = "with" "{" {WithStmt ";"} "}".
func (p *parser) parseWith() bool {
	if !p.expect(WithKeyword) {
		goto error
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(DisplayKeyword, EncodeKeyword, ExtensionKeyword, OptionalKeyword, VariantKeyword) {
		if !p.parseWithStmt() {
			goto error
		}
		if !p.expect(Semicolon) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	return true
error:
	return false
}

// WithStmt =  ("encode"|"variant"|"display"|"extension"|"optional") ["override"|"@local"] ["(" WithQualifier [","] ")"] string.
func (p *parser) parseWithStmt() bool {
	switch p.next.Kind() {
	case EncodeKeyword:
		if !p.expect(EncodeKeyword) {
			goto error
		}
	case VariantKeyword:
		if !p.expect(VariantKeyword) {
			goto error
		}
	case DisplayKeyword:
		if !p.expect(DisplayKeyword) {
			goto error
		}
	case ExtensionKeyword:
		if !p.expect(ExtensionKeyword) {
			goto error
		}
	case OptionalKeyword:
		if !p.expect(OptionalKeyword) {
			goto error
		}
	}
	if p.accept(AtLocal, OverrideKeyword) {
		switch p.next.Kind() {
		case OverrideKeyword:
			if !p.expect(OverrideKeyword) {
				goto error
			}
		case AtLocal:
			if !p.expect(AtLocal) {
				goto error
			}
		}
	}
	if p.accept(LeftParen) {
		if !p.expect(LeftParen) {
			goto error
		}
		if !p.parseWithQualifier() {
			goto error
		}
		if p.accept(Comma) {
			if !p.expect(Comma) {
				goto error
			}
		}
		if !p.expect(RightParen) {
			goto error
		}
	}
	if !p.expect(String) {
		goto error
	}
	return true
error:
	return false
}

// WithQualifier
//     = Ref
//     | "[" Expr "]"
//     | WithKind [ "except" "{" Refs "}" ]
//     .
func (p *parser) parseWithQualifier() bool {
	switch p.next.Kind() {
	case AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword:
		if !p.parseRef() {
			goto error
		}
	case LeftBracket:
		if !p.expect(LeftBracket) {
			goto error
		}
		if !p.parseExpr() {
			goto error
		}
		if !p.expect(RightBracket) {
			goto error
		}
	case AltstepKeyword, ConstKeyword, FunctionKeyword, GroupKeyword, ModuleparKeyword, SignatureKeyword, TemplateKeyword, TestcaseKeyword, TypeKeyword:
		if !p.parseWithKind() {
			goto error
		}
		if p.accept(ExceptKeyword) {
			if !p.expect(ExceptKeyword) {
				goto error
			}
			if !p.expect(LeftBrace) {
				goto error
			}
			if !p.parseRefs() {
				goto error
			}
			if !p.expect(RightBrace) {
				goto error
			}
		}
	}
	return true
error:
	return false
}

// WithKind
//     = "altstep"
//     | "const"
//     | "function"
//     | "group"
//     | "modulepar"
//     | "signature"
//     | "template"
//     | "testcase"
//     | "type"
//     .
func (p *parser) parseWithKind() bool {
	switch p.next.Kind() {
	case AltstepKeyword:
		if !p.expect(AltstepKeyword) {
			goto error
		}
	case ConstKeyword:
		if !p.expect(ConstKeyword) {
			goto error
		}
	case FunctionKeyword:
		if !p.expect(FunctionKeyword) {
			goto error
		}
	case GroupKeyword:
		if !p.expect(GroupKeyword) {
			goto error
		}
	case ModuleparKeyword:
		if !p.expect(ModuleparKeyword) {
			goto error
		}
	case SignatureKeyword:
		if !p.expect(SignatureKeyword) {
			goto error
		}
	case TemplateKeyword:
		if !p.expect(TemplateKeyword) {
			goto error
		}
	case TestcaseKeyword:
		if !p.expect(TestcaseKeyword) {
			goto error
		}
	case TypeKeyword:
		if !p.expect(TypeKeyword) {
			goto error
		}
	}
	return true
error:
	return false
}

// Refs = {Ref ","} .
func (p *parser) parseRefs() bool {
	for p.accept(AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword) {
		if !p.parseRef() {
			goto error
		}
		if !p.expect(Comma) {
			goto error
		}
	}
	return true
error:
	return false
}

// Extends = "extends" Refs.
func (p *parser) parseExtends() bool {
	if !p.expect(ExtendsKeyword) {
		goto error
	}
	if !p.parseRefs() {
		goto error
	}
	return true
error:
	return false
}

// Language = "language" {string ","}.
func (p *parser) parseLanguage() bool {
	if !p.expect(LanguageKeyword) {
		goto error
	}
	for p.accept(String) {
		if !p.expect(String) {
			goto error
		}
		if !p.expect(Comma) {
			goto error
		}
	}
	return true
error:
	return false
}

// Return = "return" [NestedTemplate] Ref {ArrayDef} .
func (p *parser) parseReturn() bool {
	if !p.expect(ReturnKeyword) {
		goto error
	}
	if p.accept(OmitKeyword, PresentKeyword, TemplateKeyword, ValueKeyword) {
		if !p.parseNestedTemplate() {
			goto error
		}
	}
	if !p.parseRef() {
		goto error
	}
	for p.accept(LeftBracket) {
		if !p.parseArrayDef() {
			goto error
		}
	}
	return true
error:
	return false
}

// ConfigSpec
//     = "runs" "on" Ref
//     | "system" Ref
//     | "mtc" Ref
//     | "port" Ref
//     | "execute" "on" Ref
//     .
func (p *parser) parseConfigSpec() bool {
	switch p.next.Kind() {
	case RunsKeyword:
		if !p.expect(RunsKeyword) {
			goto error
		}
		if !p.expect(OnKeyword) {
			goto error
		}
		if !p.parseRef() {
			goto error
		}
	case SystemKeyword:
		if !p.expect(SystemKeyword) {
			goto error
		}
		if !p.parseRef() {
			goto error
		}
	case MtcKeyword:
		if !p.expect(MtcKeyword) {
			goto error
		}
		if !p.parseRef() {
			goto error
		}
	case PortKeyword:
		if !p.expect(PortKeyword) {
			goto error
		}
		if !p.parseRef() {
			goto error
		}
	case ExecuteKeyword:
		if !p.expect(ExecuteKeyword) {
			goto error
		}
		if !p.expect(OnKeyword) {
			goto error
		}
		if !p.parseRef() {
			goto error
		}

	}
	return true
error:
	return false
}

// Exception = "exception" "(" Refs ")".
func (p *parser) parseException() bool {
	if !p.expect(ExceptionKeyword) {
		goto error
	}
	if !p.expect(LeftParen) {
		goto error
	}
	if !p.parseRefs() {
		goto error
	}
	if !p.expect(RightParen) {
		goto error
	}
	return true
error:
	return false
}

// Visibility = "private"|"public"|"friend".
func (p *parser) parseVisibility() bool {
	switch p.next.Kind() {
	case PrivateKeyword:
		if !p.expect(PrivateKeyword) {
			goto error
		}
	case PublicKeyword:
		if !p.expect(PublicKeyword) {
			goto error
		}
	case FriendKeyword:
		if !p.expect(FriendKeyword) {
			goto error
		}
	}
	return true
error:
	return false
}

// Name = identifier.
func (p *parser) parseName() bool {
	if !p.expect(Identifier) {
		goto error
	}
	return true
error:
	return false
}

// FormalTypePars = "<" FormalTypePar {"," FormalTypePar} [","] ">".
func (p *parser) parseFormalTypePars() bool {
	if !p.expect(Less) {
		goto error
	}
	if !p.parseFormalTypePar() {
		goto error
	}
	for p.accept(Comma) {
		if !p.expect(Comma) {
			goto error
		}
		if !p.parseFormalTypePar() {
			goto error
		}
	}
	if p.accept(Comma) {
		if !p.expect(Comma) {
			goto error
		}
	}
	if !p.expect(Greater) {
		goto error
	}
	return true
error:
	return false
}

// FormalTypePar = ["in"] ("type"|"signature"|Ref) Declarator.
func (p *parser) parseFormalTypePar() bool {
	if p.accept(InKeyword) {
		if !p.expect(InKeyword) {
			goto error
		}
	}
	switch p.next.Kind() {
	case TypeKeyword:
		if !p.expect(TypeKeyword) {
			goto error
		}
	case SignatureKeyword:
		if !p.expect(SignatureKeyword) {
			goto error
		}
	case AddressKeyword, AllKeyword, AnyKeyword, Identifier, MapKeyword, MtcKeyword, SelfKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UniversalKeyword, UnmapKeyword:
		if !p.parseRef() {
			goto error
		}

	}
	if !p.parseDeclarator() {
		goto error
	}
	return true
error:
	return false
}

// FormalPars = "(" FormalPar {"," FormalPar} [","] ")".
func (p *parser) parseFormalPars() bool {
	if !p.expect(LeftParen) {
		goto error
	}
	if !p.parseFormalPar() {
		goto error
	}
	for p.accept(Comma) {
		if !p.expect(Comma) {
			goto error
		}
		if !p.parseFormalPar() {
			goto error
		}
	}
	if p.accept(Comma) {
		if !p.expect(Comma) {
			goto error
		}
	}
	if !p.expect(RightParen) {
		goto error
	}
	return true
error:
	return false
}

// FormalPar = ("in"|"out"|"inout") Ref Declarator.
func (p *parser) parseFormalPar() bool {
	switch p.next.Kind() {
	case InKeyword:
		if !p.expect(InKeyword) {
			goto error
		}
	case OutKeyword:
		if !p.expect(OutKeyword) {
			goto error
		}
	case InoutKeyword:
		if !p.expect(InoutKeyword) {
			goto error
		}
	}
	if !p.parseRef() {
		goto error
	}

	if !p.parseDeclarator() {
		goto error
	}
	return true
error:
	return false
}

// Declarator = Name {ArrayDef} [":=" Expr].
func (p *parser) parseDeclarator() bool {
	if !p.parseName() {
		goto error
	}
	for p.accept(LeftBracket) {
		if !p.parseArrayDef() {
			goto error
		}
	}
	if p.accept(Assign) {
		if !p.expect(Assign) {
			goto error
		}
		if !p.parseExpr() {
			goto error
		}
	}
	return true
error:
	return false
}

// ArrayDef = "[" Expr "]".
func (p *parser) parseArrayDef() bool {
	if !p.expect(LeftBracket) {
		goto error
	}
	if !p.parseExpr() {
		goto error
	}
	if !p.expect(RightBracket) {
		goto error
	}
	return true
error:
	return false
}

// TemplateRestriction = "omit" | "value" | "present".
func (p *parser) parseTemplateRestriction() bool {
	switch p.next.Kind() {
	case OmitKeyword:
		if !p.expect(OmitKeyword) {
			goto error
		}
	case ValueKeyword:
		if !p.expect(ValueKeyword) {
			goto error
		}
	case PresentKeyword:
		if !p.expect(PresentKeyword) {
			goto error
		}
	}
	return true
error:
	return false
}

// NestedTemplate
//     = "template" ["(" TemplateRestriction ")"]
//     | TemplateRestriction
//     .
func (p *parser) parseNestedTemplate() bool {
	switch p.next.Kind() {
	case TemplateKeyword:
		if !p.expect(TemplateKeyword) {
			goto error
		}
		if p.accept(LeftParen) {
			if !p.expect(LeftParen) {
				goto error
			}
			if !p.parseTemplateRestriction() {
				goto error
			}
			if !p.expect(RightParen) {
				goto error
			}
		}
	case OmitKeyword, PresentKeyword, ValueKeyword:
		if !p.parseTemplateRestriction() {
			goto error
		}

	}
	return true
error:
	return false
}

// NestedStruct = ("record"|"set"|"union") "{" { StructMember "," } "}".
func (p *parser) parseNestedStruct() bool {
	switch p.next.Kind() {
	case RecordKeyword:
		if !p.expect(RecordKeyword) {
			goto error
		}
	case SetKeyword:
		if !p.expect(SetKeyword) {
			goto error
		}
	case UnionKeyword:
		if !p.expect(UnionKeyword) {
			goto error
		}
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(AddressKeyword, AllKeyword, AnyKeyword, AtDefault, EnumeratedKeyword, Identifier, MapKeyword, MtcKeyword, RecordKeyword, SelfKeyword, SetKeyword, SystemKeyword, ThisKeyword, TimerKeyword, UnionKeyword, UniversalKeyword, UnmapKeyword) {
		if !p.parseStructMember() {
			goto error
		}
		if !p.expect(Comma) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	return true
error:
	return false
}

// NestedList = ("record"|"set") ["length" "(" Expr ")"] "of" NestedType.
func (p *parser) parseNestedList() bool {
	switch p.next.Kind() {
	case RecordKeyword:
		if !p.expect(RecordKeyword) {
			goto error
		}
	case SetKeyword:
		if !p.expect(SetKeyword) {
			goto error
		}
	}
	if p.accept(LengthKeyword) {
		if !p.expect(LengthKeyword) {
			goto error
		}
		if !p.expect(LeftParen) {
			goto error
		}
		if !p.parseExpr() {
			goto error
		}
		if !p.expect(RightParen) {
			goto error
		}
	}
	if !p.expect(OfKeyword) {
		goto error
	}
	if !p.parseNestedType() {
		goto error
	}
	return true
error:
	return false
}

// NestedEnum = "enumerated" "{" {EnumLabel "," } "}".
func (p *parser) parseNestedEnum() bool {
	if !p.expect(EnumeratedKeyword) {
		goto error
	}
	if !p.expect(LeftBrace) {
		goto error
	}
	for p.accept(Identifier) {
		if !p.parseEnumLabel() {
			goto error
		}
		if !p.expect(Comma) {
			goto error
		}
	}
	if !p.expect(RightBrace) {
		goto error
	}
	return true
error:
	return false
}
